#include <Loci.h>
#include <Tools/stream.h>
#include "flowTypes.h"
#include "flowPsiIO.h"
#include "SA_param.h"

$include "flowPsi.lh"
$include "SA.lh"

namespace flowPsi {
  $type multi_scale param<std::string> ;
  $rule optional(multi_scale) {
  }

  $type SA_DES Constraint ;
  $type SA_DDES Constraint ;



  $rule constraint(SA_DES,SA_DDES<-multi_scale) {
    int len = $multi_scale.size() ;
    string mode ;
    for(int i=0;i<len;++i)
      if($multi_scale[i] != '2')
        mode += $multi_scale[i] ;
      else
        break ;
    $SA_DES = EMPTY ;
    $SA_DDES = EMPTY ;
    if(mode == "DES") {
      $SA_DES = $*multi_scale.domain() ;
    } else if(mode == "DDES") {
      $SA_DDES = $*multi_scale.domain() ;
    }
  }

  $type dist_noslip_des store<real> ;
  $type LG store<real> ;

  $rule pointwise(dist_noslip_des<-dist_noslip,LG) {
    const real des_param = 0.65 ;
    $dist_noslip_des = min($dist_noslip,des_param*$LG) ;
  }

  $type f_ddes store<real> ;
  $rule pointwise(f_ddes<-mu,tmu,gradv3d(u),spalart,dist_noslip,rho) {
    const tens3d &gu = $gradv3d(u) ;
    const real S = sqrt(gu.x.x*gu.x.x + gu.x.y*gu.x.y + gu.x.z*gu.x.z+
                        gu.y.x*gu.y.x + gu.y.y*gu.y.y + gu.y.z*gu.y.z+ 
                        gu.z.x*gu.z.x + gu.z.y*gu.z.y + gu.z.z*gu.z.z) ;
    const real d = $dist_noslip ;
    const real ka =$spalart.k_coeff ;
    const real r_d = ($mu+$tmu)/max($rho*S*ka*ka*d*d,1e-30) ;
    $f_ddes = 1.-tanh(512.*r_d*r_d*r_d) ;
  }
  
  $type sa_dist_noslip store<real> ;
  $rule pointwise(des::sa_dist_noslip<-dist_noslip_des),
    constraint(SA_DES,vol) {
    $sa_dist_noslip = $dist_noslip_des ;
  }
  
  $rule pointwise(ddes::sa_dist_noslip<-dist_noslip,LG,f_ddes),
    constraint(SA_DDES,vol) {
    const real des_param = 0.65 ;
    const real d = $dist_noslip ;
    $sa_dist_noslip = d - $f_ddes*max(0.,d-des_param*$LG) ;
  }

  $type SA_production param<std::string> ;
  $rule optional(SA_production),
    comments("How the Spalart Allmaras turbulence model production term is defined.  May be either 'standard' or 'DaclesMariani'.  DaclesMariani provides a modification that reduces turbulence production in vortical flows.  Note, when using DaclesMariani the constant used in the modification is defined by Cvor")
  {
    $SA_production = "standard" ;
  }
  
  $type SP_rotat Constraint ;

  $rule constraint(SP_rotat<-SA_production) {
    $SP_rotat = EMPTY ;
    if ($SA_production == "DaclesMariani") {
      $SP_rotat = $*SA_production.domain() ;
    } else if ($SA_production != "standard") {
      if(Loci::MPI_rank == 0)
        cerr << "SA_production: " << $SA_production << " is unknown, defauting to standard" << endl ;
    }
  }

  $type Cvor param<real> ;

$rule default(Cvor),comments("Vorticity correction coefficient used when SA_production is set to 'DaclesMariani'.") {
    $Cvor = 4.0 ;
  }
  

  $type S_tilda store<real> ;
  $rule apply(S_tilda<-vortMag,strainRate,S_tilda,Cvor)[Loci::Summation],
    constraint(vortMag,SP_rotat) {
    $S_tilda += $Cvor*min(0.0, ($strainRate-$vortMag)) ;
  }
}
