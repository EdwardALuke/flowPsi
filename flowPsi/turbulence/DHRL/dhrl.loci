// Modified version of Dynamic Hybrid RANS-LES Model for Loci-CHEM
// Module modification "B"
// 10/12/2017
//
// D. Keith Walters
//
// ---------------------------------------------------------------------------
//
// To implement baseline DHRL, modify .vars file as follows:
//
// loadModule: KOmegaModel
// loadModule: XXXX (where 'XXXX' is the name of the module compiled using this
//                   source file)
// turbulence_model: SST
// multi_scale: DHRL
// meanFreq: 1000000000000 (any number larger than the total expected time
//                          steps)
//
// ---------------------------------------------------------------------------
//
// By default, the RANS contributions to the turbulent stress, heat
// flux, and mass flux terms (RANS source terms) are active. This can
// be controlled using the following:
//
// dhrl_source_terms: off (default is 'on')
//
// In effect this yields pure MILES.
//
// ---------------------------------------------------------------------------
//
// By default, baseline DHRL applies the same blending function
// (alpha_dhrl) to the momentum, energy, and species transport
// equations. The blending function is based on turbulent kinetic
// energy production only, i.e. the resolved and modeled turbulent
// stress tensor.
//
// To implement a separate blending function for the energy equation,
// based on the resolved and modeled turbulent heat flux vector, add
// in .vars file:
//
// dhrl_energy_alpha: yes (default is 'no')
//
// ---------------------------------------------------------------------------
//
// To implement the modified calculation for alpha_dhrl, include in
// the .vars file:
//
// dhrl_modified_alpha: yes (default is 'no')
//
// Note the the modified version is used to switch the model to "pure"
// MILES in regions where the scales of motion are well resolved,
// regardless of the ratio of modeled to resolved production. This is
// intended to mitigate potential errors when the RANS significantly
// overpredicts TKE production, which might lead to a RANS component
// being added even when it is not appropriate. The modified switch is
// based on the ratio of resolved fluctuating strainrate to the
// "large-eddy" inverse timescale (s_ratio). The "large-eddy" inverse
// timescale is assumed to scale with the mean strainrate. In regions
// of low mean strainrate (e.g. the freestream region), the inverse
// turbulent time scale is assumed to scale with the RANS model
// estimate (omega). When the fluctuating content of the flow is well
// resolved, the value of s_ratio becomes large, indicating that an
// LES model is appropriate. Conceptually, this can be viewed as
// dividing the flowfield into two regions, an LES zone (in which
// s_ratio is large), and a hybrid RANS-LES zone in which the original
// DHRL model is used to balance LES and RANS contributions.
//
// ---------------------------------------------------------------------------
//
// For baseline DHRL, the RANS component of the turbulent stress, heat
// flux, and mass flux is based on the mean (Favre-averaged) variable
// fields. This version allows the RANS transport terms to be weighted
// between the mean and instantaneous variable fields. In general
// using mean fields allows greater resolution of fluctuating flow and
// more rapid growth of fluid instabilities and "breakdown" to LES
// type flow. Using instantaneous fields increases stability. To
// implement, in .vars file:
//
// ransFluxBlendMomentum: X
// ransFluxBlendEnergy: X
//
// Here X is any value between 0 and 1, where 0 corresponds to use of
// only instantaneous variable fields, and 1 (default) corresponds to
// use of only mean variable fields. Numbers between 0 and 1 result in
// a weighted blend of mean and instantaneous.
//
// ---------------------------------------------------------------------------
//
// To reset the counter used for computing mean (time-averaged) values:
//
// meanCountReset: X (any integer value for X greater than zero)
//

#include <Loci.h>
#include <Tools/stream.h>
#include "flowTypes.h"
#include "flowPsiIO.h"
#include "inviscidFlux.h"
#include "readGrid.h"
#include "bcTools.h"
#include "kOmega_param.h"
#include "periodic.h"

$include "FVM.lh"
$include "flowPsi.lh"
$include "kOmega.lh"
$include "dhrl.lh"

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

using std::cerr ;
using std::cout ;
using std::endl ;
using std::string ;

//#define OUTPUT_AVERAGES

// Note that this version is only compatible with the use of MILES
// for the LES component. If an SGS model is added, then the treatment
// of the instantaneous heat fluxes and species diffusion terms must be modified.
// -- DKW

namespace flowPsi {

  // DHRL model version controls
  $rule constraint(DHRL_SST_BSL_KW<-multi_scale) {
    $DHRL_SST_BSL_KW = EMPTY ;
    if($multi_scale == "DHRL" || $multi_scale == "dhrl") {
      $DHRL_SST_BSL_KW = $*multi_scale.domain() ;
    } else {
      $[Once] {
	cerr << "Warning, 'multi_scale' not set to DHRL, DHRL terms not active!" << endl ;
      }
    }
  }

  $rule default(dhrl_source_terms) {
    $dhrl_source_terms = "on" ;
  }
  $rule constraint(DHRL_SRC<-dhrl_source_terms) {
    $DHRL_SRC = EMPTY ;
    if($dhrl_source_terms == "on") {
      $DHRL_SRC = $*dhrl_source_terms.domain() ;
    } else if($dhrl_source_terms == "off") {
      $DHRL_SRC = EMPTY ;
      $[Once] {
	cout << "Note, DHRL source terms are disabled!"<< endl ;
      }
    } else {
      $[Once] {
	cerr << "dhrl_source_terms = " << $dhrl_source_terms << " not understood, defaulting to 'on'" << endl;
	$DHRL_SRC = $*dhrl_source_terms.domain() ;
      }
    }
  }

  $rule default(dhrl_modified_alpha) {
    $dhrl_modified_alpha = "no" ;
  }
  $rule constraint(DHRL_ALPHA_MOD<-dhrl_modified_alpha) {
    $DHRL_ALPHA_MOD = EMPTY ;
    if($dhrl_modified_alpha == "yes" || $dhrl_modified_alpha == "on") {$DHRL_ALPHA_MOD = $*dhrl_modified_alpha.domain() ;}
  }

  $rule default(dhrl_energy_alpha) {
    $dhrl_energy_alpha = "no" ;
  }
  $rule constraint(DHRL_ALPHA_ENERGY<-dhrl_energy_alpha) {
    $DHRL_ALPHA_ENERGY = EMPTY ;
    if($dhrl_energy_alpha == "yes" || $dhrl_energy_alpha == "on") {$DHRL_ALPHA_ENERGY = $*dhrl_energy_alpha.domain() ;}
  }

// Default use mean gradients for RANS flux terms
  $rule default(ransFluxBlendMomentum) { $ransFluxBlendMomentum = 1. ; }
  $rule default(ransFluxBlendEnergy) { $ransFluxBlendEnergy = 1. ; }

  // Time-averaged variables
  $rule pointwise(rho_avg<-scalarMean(rho),rho) {$rho_avg = $scalarMean(rho)>1e-30?$scalarMean(rho):$rho ;}
  $rule pointwise(cr->rho_avg<-pmap->cl->rho_avg) {$cr->$rho_avg = $pmap->$cl->$rho_avg ;}
  $rule pointwise(dhrl::rho_t<-rho_avg) {$rho_t = $rho_avg; }

  $rule pointwise(dhrl::rho_t_f<-(cl,cr)->(rho_t,vol)) {
    real rvols = 1./($cl->$vol+$cr->$vol) ;
    $rho_t_f = rvols*($cr->$vol*$cl->$rho_t+$cl->$vol*$cr->$rho_t) ;
  }
  $rule pointwise(dhrl::rho_t_f<-ci->rho_t) { $rho_t_f = $ci->$rho_t ; }

  $rule pointwise(u_avg<-vect3dFavreMean(u),u)
  { $u_avg =$vect3dFavreMean(u) ;}
  $rule pointwise(cr->u_avg<-pmap->cl->u_avg,pmap->ref->periodicTransform)
  { 
    const rigid_transform &frame = $pmap->$ref->$periodicTransform ;
    $cr->$u_avg = frame.rotate_vec($pmap->$cl->$u_avg) ;
  }
  $rule pointwise(u_avg_f<-(cl,cr)->(u_avg,vol)) {
    real rvols = 1./($cl->$vol+$cr->$vol) ;
    $u_avg_f = rvols*($cr->$vol*$cl->$u_avg+$cl->$vol*$cr->$u_avg) ;
  }
  $rule pointwise(u_avg_f<-vect3dFavreMean_f(u)){
    $u_avg_f = $vect3dFavreMean_f(u);
  }

  $rule pointwise(dhrl::u_t_f<-u_avg_f) {$u_t_f = $u_avg_f ; }
  $rule pointwise(dhrl::ui_t<-ci->u_avg) { $ui_t=$ci->$u_avg; }

  $rule pointwise(mu_avg<-scalarMean(mu),mu)
  {$mu_avg = $scalarMean(mu)>1e-30?$scalarMean(mu):$mu ;}
  $rule pointwise(cr->mu_avg<-pmap->cl->mu_avg)
  {$cr->$mu_avg = $pmap->$cl->$mu_avg ;}
  $rule pointwise(dhrl::mu_lam<-mu_avg) { $mu_lam = $mu_avg; }

  $rule pointwise(dhrl::mu_lam_f<-(cl,cr)->(mu_lam,vol)) {
    real rvols = 1./($cl->$vol+$cr->$vol) ;
    $mu_lam_f = rvols*($cr->$vol*$cl->$mu_lam+$cl->$vol*$cr->$mu_lam) ;
  }
  $rule pointwise(dhrl::mu_lam_f<-ci->mu_lam) { $mu_lam_f = $ci->$mu_lam ;}

  $rule pointwise(dhrl::soundSpeed_t<-scalarMean(soundSpeed),soundSpeed)
  { $soundSpeed_t = $scalarMean(soundSpeed)>1e-30?$scalarMean(soundSpeed):$soundSpeed ; }

  $rule pointwise(dhrl::strainRate_t<-gradv3d(u_avg)) {
    const real dudx = $gradv3d(u_avg).x.x ;
    const real dvdy = $gradv3d(u_avg).y.y ;
    const real dwdz = $gradv3d(u_avg).z.z ;
    const real dvdx = $gradv3d(u_avg).y.x ;
    const real dwdx = $gradv3d(u_avg).z.x ;
    const real dwdy = $gradv3d(u_avg).z.y ;
    const real dudy = $gradv3d(u_avg).x.y ;
    const real dudz = $gradv3d(u_avg).x.z ;
    const real dvdz = $gradv3d(u_avg).y.z ;

    const real S2 = 2.*(dudx*dudx + dvdy*dvdy + dwdz*dwdz)
      + (dudy+dvdx)*(dudy+dvdx) + (dudz+dwdx)*(dudz+dwdx)
      + (dvdz+dwdy)*(dvdz+dwdy) ;
    $strainRate_t = sqrt(S2) ;
  }

  $rule pointwise(dhrl::vortMag_t<-gradv3d(u_avg)) {
    vect3d vort($gradv3d(u_avg).z.y-$gradv3d(u_avg).y.z,
		$gradv3d(u_avg).x.z-$gradv3d(u_avg).z.x,
		$gradv3d(u_avg).y.x-$gradv3d(u_avg).x.y) ;
    $vortMag_t = norm(vort) ;
  }

  $rule pointwise(dhrl::divu_t<-gradv3d(u_avg)) {
    const real dvdy = $gradv3d(u_avg).y.y ;
    const real dwdz = $gradv3d(u_avg).z.z ;
    const real dudx = $gradv3d(u_avg).x.x ;
    $divu_t = (dudx+dvdy+dwdz) ;
  }

  $rule pointwise(uv_avg<-vect3dFavreVar(u),vect3dFavreCoVar(u)) {
    $uv_avg.xx = $vect3dFavreVar(u).x ;
    $uv_avg.yy = $vect3dFavreVar(u).y ;
    $uv_avg.zz = $vect3dFavreVar(u).z ;
    $uv_avg.xy = $vect3dFavreCoVar(u).z ;
    $uv_avg.xz = $vect3dFavreCoVar(u).y ;
    $uv_avg.yz = $vect3dFavreCoVar(u).x ;
  }

  $rule pointwise(temp_avg<-scalarFavreMean(temperature)) {$temp_avg = $scalarFavreMean(temperature) ;}
  $rule pointwise(cr->temp_avg<-pmap->cl->temp_avg) {$cr->$temp_avg = $pmap->$cl->$temp_avg ;}

  $rule pointwise(temp_avg_f<-(cl,cr)->(temp_avg,vol)) {
    real rvols = 1./($cl->$vol+$cr->$vol) ;
    $temp_avg_f = rvols*($cr->$vol*$cl->$temp_avg+$cl->$vol*$cr->$temp_avg) ;
  }
  $rule pointwise(temp_avg_f<-ci->temp_avg) { $temp_avg_f = $ci->$temp_avg ; }

  // DHRL hooks

  // Modify instantaneous turbulent viscosity
  $rule pointwise(dhrl::kw::tmu<-alpha_dhrl,tmu_sgs),
    constraint(k,w,SST_BSL_KW,DHRL_SST_BSL_KW)
  { $tmu = $alpha_dhrl*$tmu_sgs ; }

  $rule pointwise(dhrl::wilcox08::kw::tmu<-alpha_dhrl,tmu_sgs),
    constraint(k,w,Wilcox08Model,NOT_MS_SST_BSL_KW,DHRL_SST_BSL_KW)
  { $tmu = $alpha_dhrl*$tmu_sgs ; }


  //round jet parameter
  $type chiw store<real> ;
  $rule pointwise(dhrl::chiw<-sst1m,gradv3d(u_avg),divu_t,w),
    constraint(divu_t,w,SST_BSL) {
    const real dudx = $gradv3d(u_avg).x.x ;
    const real dvdy = $gradv3d(u_avg).y.y ;
    const real dwdz = $gradv3d(u_avg).z.z ;
    const real dvdx = $gradv3d(u_avg).y.x ;
    const real dwdx = $gradv3d(u_avg).z.x ;
    const real dwdy = $gradv3d(u_avg).z.y ;
    const real dudy = $gradv3d(u_avg).x.y ;
    const real dudz = $gradv3d(u_avg).x.z ;
    const real dvdz = $gradv3d(u_avg).y.z ;

    const real wx = dwdy-dvdz ;
    const real wy = dudz-dwdx ;
    const real wz = dvdx-dudy ;
    const real s12 = dudy+dvdx ;
    const real s13 = dudz+dwdx ;
    const real s23 = dvdz+dwdy ;

    const real oms = (s12*wx*wy+s13*wx*wz+s23*wy*wz)-
      (dudx-0.5*$divu_t)*(wy*wy+wz*wz) -
      (dvdy-0.5*$divu_t)*(wx*wx+wz*wz) -
      (dwdz-0.5*$divu_t)*(wx*wx+wy*wy) ;

    $chiw = 0.25*abs(oms/pow($sst1m.betas*$w,3)) ;
  }

  $rule pointwise(dhrl::wilcox98::chiw<-sst1m,gradv3d(u_avg),w),
    constraint(Wilcox98Model,w,gradv3d(u_avg)) {
    const real dudx = $gradv3d(u_avg).x.x ;
    const real dvdy = $gradv3d(u_avg).y.y ;
    const real dwdz = $gradv3d(u_avg).z.z ;
    const real dvdx = $gradv3d(u_avg).y.x ;
    const real dwdx = $gradv3d(u_avg).z.x ;
    const real dwdy = $gradv3d(u_avg).z.y ;
    const real dudy = $gradv3d(u_avg).x.y ;
    const real dudz = $gradv3d(u_avg).x.z ;
    const real dvdz = $gradv3d(u_avg).y.z ;

    const real wx = dwdy-dvdz ;
    const real wy = dudz-dwdx ;
    const real wz = dvdx-dudy ;
    const real s12 = dudy+dvdx ;
    const real s13 = dudz+dwdx ;
    const real s23 = dvdz+dwdy ;

    const real oms = dudx*(wy*wy+wz*wz) + dvdy*(wx*wx+wz*wz) +
      dwdz*(wx*wx+wy*wy) - (s12*wx*wy+s13*wx*wz+s23*wy*wz) ;

    $chiw = 0.25*abs(oms/pow($sst1m.betas*$w,3)) ;
  }

  $type kw_tmu store<real> ;
  $type kw_tmu_f store<real> ;

  $rule pointwise(dhrl::shear::stress_scalar<-gradv3d(u_avg),kw_tmu),
    constraint(shear_production,kw_tmu,gradv3d(u_avg),DHRL_SST_BSL_KW) {
    const real tmu = $kw_tmu ;
    const real dvdx = $gradv3d(u_avg).y.x ;
    const real dwdx = $gradv3d(u_avg).z.x ;
    const real dwdy = $gradv3d(u_avg).z.y ;
    const real dudy = $gradv3d(u_avg).x.y ;
    const real dudz = $gradv3d(u_avg).x.z ;
    const real dvdz = $gradv3d(u_avg).y.z ;

    $stress_scalar = tmu*((dudy+dvdx)*(dudy+dvdx)+(dudz+dwdx)*(dudz+dwdx)
			  +(dvdz+dwdy)*(dvdz+dwdy)) ;
  }

  $rule pointwise(dhrl::lam_tau_w<-gradv3d_f(u_avg),mu_lam_f,area),
    constraint(viscousWall_BC){
    symmetricTensor tau ;
    real mu_lam = $mu_lam_f ;

    real dudx = $gradv3d_f(u_avg).x.x ;
    real dvdy = $gradv3d_f(u_avg).y.y ;
    real dwdz = $gradv3d_f(u_avg).z.z ;
    real dvdx = $gradv3d_f(u_avg).y.x ;
    real dwdx = $gradv3d_f(u_avg).z.x ;
    real dwdy = $gradv3d_f(u_avg).z.y ;
    real dudy = $gradv3d_f(u_avg).x.y ;
    real dudz = $gradv3d_f(u_avg).x.z ;
    real dvdz = $gradv3d_f(u_avg).y.z ;

    real divm = (dudx+dvdy+dwdz)*(1./3.) ;
    tau.xx = 2.0*mu_lam*(dudx-divm) ;
    tau.yy = 2.0*mu_lam*(dvdy-divm) ;
    tau.zz = 2.0*mu_lam*(dwdz-divm) ;

    tau.xy = mu_lam*(dudy+dvdx) ;
    tau.xz = mu_lam*(dudz+dwdx) ;
    tau.yz = mu_lam*(dvdz+dwdy) ;

    const vect3d an = $area.n ;
    const vect3d tau_w = vect3d(tau.xx*an.x + tau.xy*an.y + tau.xz*an.z,
                                tau.xy*an.x + tau.yy*an.y + tau.yz*an.z,
                                tau.xz*an.x + tau.yz*an.y + tau.zz*an.z) ;
    $lam_tau_w = sqrt(dot(tau_w,tau_w)) ;
  }

  // Compute DHRL blending parameters
  // --Momentum
  $rule pointwise(prod_rans<-P_k), constraint(rho_t) { $prod_rans = $P_k ; }

  $rule pointwise(prod_les<-rho_t,uv_avg,gradv3d(u_avg)),
    constraint(uv_avg) {
    $prod_les =  - $rho_t * ($uv_avg.xx*$gradv3d(u_avg).x.x
		 + $uv_avg.xy*($gradv3d(u_avg).x.y+$gradv3d(u_avg).y.x)
		 + $uv_avg.xz*($gradv3d(u_avg).x.z+$gradv3d(u_avg).z.x)
		 + $uv_avg.yy*$gradv3d(u_avg).y.y
		 + $uv_avg.yz*($gradv3d(u_avg).y.z+$gradv3d(u_avg).z.y)
		 + $uv_avg.zz*$gradv3d(u_avg).z.z) ;
  }

  // MILES default
  $rule pointwise(prod_sgs), constraint(geom_cells) {$prod_sgs = 0. ;} 

  $rule pointwise(alpha_star_dhrl<-prod_les,prod_rans,prod_sgs),
    constraint(prod_les) {
    const real denom = max<real>($prod_rans-$prod_sgs,1.e-16) ;
    $alpha_star_dhrl = min<real>(max<real>($prod_les/denom,0.),1.) ;
  }

  $rule pointwise(alpha_dhrl<-alpha_star_dhrl) { // Original DHRL formulation
    $alpha_dhrl = $alpha_star_dhrl ;
  }

  $rule pointwise(sij_sij<-gradv3d(u)), constraint(geom_cells) {
    const real s11 = $gradv3d(u).x.x ;
    const real s22 = $gradv3d(u).y.y ;
    const real s33 = $gradv3d(u).z.z ;
    const real s12 = 0.5*($gradv3d(u).x.y+$gradv3d(u).y.x) ;
    const real s13 = 0.5*($gradv3d(u).x.z+$gradv3d(u).z.x) ;
    const real s23 = 0.5*($gradv3d(u).y.z+$gradv3d(u).z.y) ;
    $sij_sij = s11*s11+s22*s22+s33*s33+2.*(s12*s12+s13*s13+s23*s23) ;
  }

  $rule pointwise(sij_sij_avg<-scalarFavreMean(sij_sij)) {
    $sij_sij_avg = $scalarFavreMean(sij_sij) ;
  }

  $rule pointwise(s_ratio<-sij_sij_avg,gradv3d(u_avg),w) {
    const real s11_avg = $gradv3d(u_avg).x.x ;
    const real s22_avg = $gradv3d(u_avg).y.y ;
    const real s33_avg = $gradv3d(u_avg).z.z ;
    const real s12_avg = 0.5*($gradv3d(u_avg).x.y+$gradv3d(u_avg).y.x) ;
    const real s13_avg = 0.5*($gradv3d(u_avg).x.z+$gradv3d(u_avg).z.x) ;
    const real s23_avg = 0.5*($gradv3d(u_avg).y.z+$gradv3d(u_avg).z.y) ;
    const real s_avg_2 = s11_avg*s11_avg+s22_avg*s22_avg+s33_avg*s33_avg
      + 2.*(s12_avg*s12_avg+s13_avg*s13_avg+s23_avg*s23_avg) ;
    // Use SST estimate for large-eddy time scale in low strainrate regions
    const real denom = max<real>(s_avg_2,0.09*$w*$w)+1.e-16 ; 
    $s_ratio = ($sij_sij_avg-s_avg_2)/denom ;
  }

  $rule pointwise(s_ratio_f<-ci->s_ratio) { $s_ratio_f = $ci->$s_ratio ; }

  $rule pointwise(gamma_dhrl<-s_ratio)
  { $gamma_dhrl = 1. - 1./(1.+pow($s_ratio/4.,4.)) ; }

  // Modified DHRL formulation
  $rule pointwise(modified::alpha_dhrl<-alpha_star_dhrl,gamma_dhrl),
    constraint(DHRL_ALPHA_MOD,geom_cells)   
  { $alpha_dhrl = max($alpha_star_dhrl,$gamma_dhrl) ; }

  //--Energy
  // Original DHRL -- use same alpha for both momentum and energy
  $rule pointwise(alpha_star_energy_dhrl<-alpha_dhrl)
  {$alpha_star_energy_dhrl = $alpha_dhrl ;} 

  $rule pointwise(hflux_scalar_les<-cput_avg,rho_t,grads(temp_avg)) {
    const vect3d heat_flux_les = -$rho_t*$cput_avg ;
    $hflux_scalar_les = dot(heat_flux_les,$grads(temp_avg)) ;
  }

  $rule pointwise(hflux_scalar_rans<-kcond_rans,grads(temp_avg)) {
    $hflux_scalar_rans = $kcond_rans*dot($grads(temp_avg),$grads(temp_avg)) ;
  }

  // THIS IS ONLY VALID FOR MILES!!!!
  $rule pointwise(hflux_scalar_sgs), constraint(geom_cells)
  { $hflux_scalar_sgs = 0. ; }

  // Original (non-modified) alpha
  $rule pointwise(alpha_energy_dhrl<-alpha_star_energy_dhrl),
    constraint(geom_cells)
  { $alpha_energy_dhrl = $alpha_star_energy_dhrl ; }

  $rule pointwise(separate::alpha_star_energy_dhrl<-hflux_scalar_les,hflux_scalar_rans,hflux_scalar_sgs), constraint(geom_cells,DHRL_ALPHA_ENERGY) {
    const real denom = max<real>($hflux_scalar_rans-$hflux_scalar_sgs,1.e-16) ;
    $alpha_star_energy_dhrl = min<real>(max<real>($hflux_scalar_les/denom,0.),1.) ;
  }

  $rule pointwise(modified::alpha_energy_dhrl<-alpha_star_energy_dhrl,gamma_dhrl), constraint(geom_cells,DHRL_ALPHA_MOD) {
    $alpha_energy_dhrl = max($alpha_star_energy_dhrl,$gamma_dhrl) ;
  }

  // Compute RANS diffusion contribution to momentum, energy and mass equations
  $rule pointwise(vis_flux_rans<-area,tau_rans),
    constraint(no_symmetry_BC) {
    const vect3d an=$area.n ;
    const real sada=$area.sada ;

    $vis_flux_rans.x = ($tau_rans.xx*an.x +$tau_rans.xy*an.y
			+$tau_rans.xz*an.z)*sada ;
    $vis_flux_rans.y = ($tau_rans.xy*an.x +$tau_rans.yy*an.y
			+$tau_rans.yz*an.z)*sada ;
    $vis_flux_rans.z = ($tau_rans.xz*an.x +$tau_rans.yz*an.y
			+$tau_rans.zz*an.z)*sada ;
  }

  // Compute RANS stress term on faces
  $rule pointwise(tau_rans<-tmu_rans_eff_f,gradv3d_f(u_avg),gradv3d_f(u),ransFluxBlendMomentum) {
    const real c_avg = $ransFluxBlendMomentum ;
    real dudx = c_avg*$gradv3d_f(u_avg).x.x + (1.-c_avg)*$gradv3d_f(u).x.x ;
    real dudy = c_avg*$gradv3d_f(u_avg).x.y + (1.-c_avg)*$gradv3d_f(u).x.y ;
    real dudz = c_avg*$gradv3d_f(u_avg).x.z + (1.-c_avg)*$gradv3d_f(u).x.z ;
    real dvdx = c_avg*$gradv3d_f(u_avg).y.x + (1.-c_avg)*$gradv3d_f(u).y.x ;
    real dvdy = c_avg*$gradv3d_f(u_avg).y.y + (1.-c_avg)*$gradv3d_f(u).y.y ;
    real dvdz = c_avg*$gradv3d_f(u_avg).y.z + (1.-c_avg)*$gradv3d_f(u).y.z ;
    real dwdx = c_avg*$gradv3d_f(u_avg).z.x + (1.-c_avg)*$gradv3d_f(u).z.x ;
    real dwdy = c_avg*$gradv3d_f(u_avg).z.y + (1.-c_avg)*$gradv3d_f(u).z.y ;
    real dwdz = c_avg*$gradv3d_f(u_avg).z.z + (1.-c_avg)*$gradv3d_f(u).z.z ;
    real divm = (1./3.)*(dudx+dvdy+dwdz) ;
    $tau_rans.xx = 2.*$tmu_rans_eff_f*(dudx-divm) ;
    $tau_rans.yy = 2.*$tmu_rans_eff_f*(dvdy-divm) ;
    $tau_rans.zz = 2.*$tmu_rans_eff_f*(dwdz-divm) ;
    $tau_rans.xy = $tmu_rans_eff_f*(dudy+dvdx) ;
    $tau_rans.xz = $tmu_rans_eff_f*(dudz+dwdx) ;
    $tau_rans.yz = $tmu_rans_eff_f*(dvdz+dwdy) ;
  }

  $rule pointwise(vis_energy_flux_rans<-vis_flux_rans,u_f),
    constraint(no_symmetry_BC)
  { $vis_energy_flux_rans = dot($vis_flux_rans,$u_f) ; }

  $rule pointwise(heat_flux_rans<-area,grads_f(temp_avg),grads_f(temperature),ransFluxBlendEnergy,kcond_rans_eff_f),
    constraint(no_symmetry_BC) {
    const vect3d an = $area.n ;
    const real sada = $area.sada ;

    const real c_avg = $ransFluxBlendEnergy ;
    const vect3d grad_eff = c_avg*$grads_f(temp_avg) + (1.-c_avg)*$grads_f(temperature) ;

    $heat_flux_rans = $kcond_rans_eff_f*dot(grad_eff,an)*sada ;
  }

  $rule pointwise(cr->tmu_rans<-pmap->cl->tmu_rans) {$cr->$tmu_rans = $pmap->$cl->$tmu_rans ;}

  $rule pointwise(tmu_rans_f<-kw_tmu_f) {
    $tmu_rans_f = $kw_tmu_f;
  }

  $rule pointwise(cr->alpha_dhrl<-pmap->cl->alpha_dhrl) {$cr->$alpha_dhrl = $pmap->$cl->$alpha_dhrl ;}

  $rule pointwise(alpha_dhrl_f<-(cl,cr)->(alpha_dhrl,vol)) {
    real rvols = 1./($cl->$vol+$cr->$vol) ;
    $alpha_dhrl_f = rvols*($cr->$vol*$cl->$alpha_dhrl+$cl->$vol*$cr->$alpha_dhrl) ;
  }

  $rule pointwise(alpha_dhrl_f<-ci->alpha_dhrl) {
    $alpha_dhrl_f = $ci->$alpha_dhrl ;
  }

  $rule pointwise(tmu_rans_eff_f<-tmu_rans_f,alpha_dhrl_f) {
    $tmu_rans_eff_f = (1.-$alpha_dhrl_f)*$tmu_rans_f ;
  }

  //  $rule pointwise(cr->kcond_rans<-pmap->cl->kcond_rans) {$cr->$kcond_rans = $pmap->$cl->$kcond_rans ;}

  $rule pointwise(kcond_rans_f<-(cl,cr)->(kcond_rans,vol)) {
    real rvols = 1./($cl->$vol+$cr->$vol) ;
    $kcond_rans_f = rvols*($cr->$vol*$cl->$kcond_rans+$cl->$vol*$cr->$kcond_rans) ;
  }

  $rule pointwise(kcond_rans_f<-ci->kcond_rans)
  { $kcond_rans_f = $ci->$kcond_rans ; }

  $rule pointwise(wall::kcond_rans_f),
    constraint(ci->geom_cells,viscousWall_BC)
  { $kcond_rans_f = 0. ; }

  $rule pointwise(cr->alpha_energy_dhrl<-pmap->cl->alpha_energy_dhrl)
  {$cr->$alpha_energy_dhrl = $pmap->$cl->$alpha_energy_dhrl ;}

  $rule pointwise(alpha_energy_dhrl_f<-(cl,cr)->(alpha_energy_dhrl,vol)) {
    real rvols = 1./($cl->$vol+$cr->$vol) ;
    $alpha_energy_dhrl_f = rvols*($cr->$vol*$cl->$alpha_energy_dhrl+$cl->$vol*$cr->$alpha_energy_dhrl) ;
  }

  $rule pointwise(alpha_energy_dhrl_f<-ci->alpha_energy_dhrl) {
    $alpha_energy_dhrl_f = $ci->$alpha_energy_dhrl ;
  }

  $rule pointwise(kcond_rans_eff_f<-alpha_energy_dhrl_f,kcond_rans_f) {
    $kcond_rans_eff_f = (1.-$alpha_energy_dhrl_f)*$kcond_rans_f ;
  }

  // Modifications specific to particular RANS models used

  // ----- SST/BSL/Wilcox KW Models ----- //

  // Definition of RANS turbulence viscosity
  $rule pointwise(tmu_rans<-kw_tmu),
    constraint(rho_t,k,geom_cells) {
    $tmu_rans = $kw_tmu ;
  }

  $rule pointwise(kcond_rans<-turbulentPrandtlNumber,tmu_rans,cp_avg) {
    const real prt = $turbulentPrandtlNumber ;
    $kcond_rans = $tmu_rans*$cp_avg/prt ;
  }

  // Modifications specific to particular LES models used
  // MILES
  $rule pointwise(tmu_sgs<-mu) {$tmu_sgs = 1.e-12*$mu ;}

}
