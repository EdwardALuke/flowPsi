#include "inviscidFlux.h"
#include "flowTypes.h"
#include "flowPsiIO.h"
$include "flowPsi.lh"

namespace flowPsi {

  $type inviscidFlux param<std::string> ;
  $type useKECFluxScheme Constraint ;
  $type useSkewSymmetricFluxScheme Constraint ;

  $rule default(inviscidFlux) {
    $inviscidFlux = "hllc" ;
  }

  $rule constraint(useKECFluxScheme,useSkewSymmetricFluxScheme<-inviscidFlux) {
    $useKECFluxScheme = EMPTY ;
    $useSkewSymmetricFluxScheme = EMPTY ;
    if($inviscidFlux == "KEC" || $inviscidFlux == "kec") {
      $useKECFluxScheme = ~EMPTY ;
    }
    if($inviscidFlux == "SSF" || $inviscidFlux == "ssf") {
      $useSkewSymmetricFluxScheme = ~EMPTY ;
    }
  }
  $type alpha_diss store<real> ;

  $type veldiv store<real> ;
  $rule unit(veldiv),constraint(geom_cells) {
    $veldiv = 0 ;
  }
  
  $type ufn store<real> ;
  $rule pointwise(priority::ufn<-(cl,cr)->(u,cellcenter),area,facecenter,gradv3d_f(u)) {
    const vect3d dv = $facecenter -0.5*($cl->$cellcenter+$cr->$cellcenter) ;
    //    const vect3d dv(0.,0.,0.) ;
    const vect3d ucor = dot($gradv3d_f(u),dv) ;
    const vect3d uf = 0.5*($cl->$u+$cr->$u) ;
    $ufn = dot(uf+ucor,$area.n)*$area.sada ;
  }
  $rule pointwise(ufn<-u_f,area) {
    $ufn = dot($u_f,$area.n)*$area.sada ;
  }
  $rule apply(cl->veldiv<-ufn)[Loci::Summation] {
    join($cl->$veldiv,$ufn) ;
  }
  $rule apply(cr->veldiv<-ufn)[Loci::Summation] {
    join($cr->$veldiv,-$ufn) ;
  }

  $type LDS_dissipationLimit param<real> ;

  $rule default(LDS_dissipationLimit) {
    $LDS_dissipationLimit = 1.0 ;
  }

  $type LDS_ducrosFactor param<real> ;
  $rule default(LDS_ducrosFactor) {
    $LDS_ducrosFactor = 0.0 ;
  }

  $type LDS_useUpwind param<real> ;
  $rule default(LDS_useUpwind) {
    $LDS_useUpwind = 0.0 ;
  }
  $type LDS_compFactor param<real> ;
  $rule default(LDS_compFactor) {
    $LDS_compFactor = 10.0 ;
  }

  $type compDiss store<real> ;
  $rule unit(compDiss),constraint(geom_cells) {
    $compDiss = 0 ;
  }

  $rule apply((cl,cr)->compDiss<-(cl,cr)->(veldiv,soundSpeed),LDS_compFactor,area)[Loci::Maximum],constraint((cl,cr)->geom_cells) {

    real factor = $LDS_compFactor*(fabs($cl->$veldiv) + fabs($cr->$veldiv))/
        (($cl->$soundSpeed + $cr->$soundSpeed)*$area.sada) ;
    factor = factor*factor ;
    join($cl->$compDiss,factor) ;
    join($cr->$compDiss,factor) ;
  }

  $rule pointwise(alpha_diss<-veldiv,vol,vortMag,LDS_dissipationLimit,LDS_useUpwind,compDiss,LDS_ducrosFactor,(upper,lower,boundary_map)->facecenter),constraint(geom_cells,u) {
    real theta_2 = $veldiv*$veldiv/($vol*$vol) ;
    real omega_2 = $vortMag*$vortMag ;
    $alpha_diss = max($LDS_ducrosFactor*theta_2/(theta_2+omega_2+1e-10),$compDiss) ;
    int nfaces = $upper.size()+$lower.size()+$boundary_map.size() ;
    $alpha_diss = (nfaces > 5)?($alpha_diss):1.0 ;
    $alpha_diss = min($alpha_diss,$LDS_dissipationLimit) ;
    $alpha_diss = max($alpha_diss,$LDS_useUpwind) ;
  }

  $rule pointwise(cr->alpha_diss<-pmap->cl->alpha_diss) {
    $cr->$alpha_diss = $pmap->$cl->$alpha_diss ;
  }

  $type LDS_nonSymmetricCoeff param<double> ;

  $rule default(LDS_nonSymmetricCoeff) {
    $LDS_nonSymmetricCoeff = 1.0 ;
  }
  $type alpha_geom store<float> ;

  $rule pointwise(alpha_geom<-area,facecenter,(cl,cr)->cellcenter,
                  (cl,cr)->vol,LDS_nonSymmetricCoeff) {
    const vect3d df = $cr->$cellcenter-$cl->$cellcenter ;
    const vect3d dv = $facecenter -0.5*($cl->$cellcenter+$cr->$cellcenter) ;
    double a1 = 2.*sqrt(dot(dv,dv)/dot(df,df)) ;
    double a2 = 1.-dot($area.n,df)/norm(df) ;
    double vl = $cl->$vol ;
    double vr = $cr->$vol ;
    double a3 = 1.-pow(min(vl,vr)/max(vl,vr),1/3) ;
    double a = max(max(a1,a2),a3) ;
    double f = $LDS_nonSymmetricCoeff ;
    $alpha_geom = max(min(f*a+(1.-f)*a*a,1.0),0.0) ;
  }
  

  
#undef NOCORRECTION
  // NOCORRECTION disables correction that accounts for faces with locations
  // offset from the midpoint between cellcenters (included as a switch for
  // testing purposes.  Do not turn this on by default.
//#define NOCORRECTION

  $rule pointwise(KEC::iflux<-(cl,cr)->(gagePressure,temperature,u,cellcenter),
		  (cl,cr)->alpha_diss,alpha_geom,
		  (cl,cr)->(limiters(temperature),limiters(gagePressure),
			    limiterv3d(u)),
		  leftsP(gagePressure,minPg),rightsP(gagePressure,minPg),
		  leftsP(temperature,Zero),rightsP(temperature,Zero),
		  facecenter,gradv3d_f(u),grads_f(gagePressure),
		  grads_f(temperature),
		  leftv3d(u),rightv3d(u),
		  Pambient,area,Rtilde,gamma,us_n),
    constraint(useKECFluxScheme,(cl,cr)->vol) {

#ifdef NOCORRECTION
    const vect3d dv(0.,0.,0.) ;
#else
    const vect3d dv = $facecenter -0.5*($cl->$cellcenter+$cr->$cellcenter) ;
#endif
    
    vect3d ucor = dot($gradv3d_f(u),dv) ;
    const vect3d uf = 0.5*($cl->$u+$cr->$u) ; 
    const vect3d an = $area.n ;
    const real sada = $area.sada ;

    ucor.x *= ($cl->$limiterv3d(u).x)*($cr->$limiterv3d(u).x) ;
    ucor.y *= ($cl->$limiterv3d(u).y)*($cr->$limiterv3d(u).y) ;
    ucor.z *= ($cl->$limiterv3d(u).z)*($cr->$limiterv3d(u).z) ;
		 
    const real ufn = dot(uf+ucor,an) - $us_n ;
    
    const real pgl = $cl->$gagePressure ;
    const real pgr = $cr->$gagePressure ;
 
    real pgf = 0.5*(pgl+pgr) + (dot($grads_f(gagePressure),dv)*
				($cl->$limiters(gagePressure))*
				($cr->$limiters(gagePressure))) ;

    // limit the temperature correction for stability
    real dt = (dot($grads_f(temperature),dv))*
      ($cl->$limiters(temperature))*($cr->$limiters(temperature)) ;
    real tf = (0.5*($cl->$temperature+$cr->$temperature) + dt) ;

    const real rf = (pgf+$Pambient)/($Rtilde*tf) ;
    const real mdot = rf*ufn*sada ;
    $iflux[0] = mdot ;
    const int mi = 1 ;
    // Compute kinetic energy flux

    const real apgf = pgf*sada ;
    $iflux[mi+0] = mdot*(uf.x+ucor.x) + apgf*an.x ;
    $iflux[mi+1] = mdot*(uf.y+ucor.y) + apgf*an.y ;
    $iflux[mi+2] = mdot*(uf.z+ucor.z) + apgf*an.z ;

    real kf = 0.25*(dot($cl->$u,$cl->$u) + dot($cr->$u,$cr->$u)) ; 
    // compute kinetic energy consistent part plus delta kinetic energy
    // of correction
    real ktilde = (dot(uf,uf)-kf) + (dot(uf,ucor) + .5*dot(ucor,ucor)) ;
    //            ^KE consistent^   ^ delta KE due to correction     ^ 
    real e_internalf = $Rtilde*tf/($gamma-1) ;
    $iflux[4] = mdot*(ktilde+e_internalf) + (ufn+$us_n)*(pgf+$Pambient)*sada ;

    const real dp = 2.*fabs($leftsP(gagePressure,minPg)-
			    $rightsP(gagePressure,minPg))/
      (rf*$gamma*$Rtilde*tf) ;
    
    const real ap = max(0.0,min(1.0,dp*1.0-0.5)) ;
    const real local_alpha = max(ap,real($alpha_geom)) ;
    const real alpha = max(max($cl->$alpha_diss,$cr->$alpha_diss),local_alpha) ;

    if(alpha >1e-10) {
      Loci::Array<real,5> uflux ;
      hllc_flux(uflux,
                $leftsP(gagePressure,minPg),$leftsP(temperature,Zero),
                $leftv3d(u),
                $rightsP(gagePressure,minPg),$rightsP(temperature,Zero),
                $rightv3d(u),
                an,sada,$Pambient,$Rtilde,$gamma,$us_n) ;
      for(int i=0;i<5;++i)
	$iflux[i] = alpha*uflux[i]+(1.-alpha)*$iflux[i] ;
    }
  }

  $type SSF_Coeff param<double> ;
  $rule default(SSF_Coeff) {
    $SSF_Coeff = 1.0 ;
  }

  $rule pointwise(SSF::iflux<-(cl,cr)->(gagePressure,temperature,u,cellcenter),
                  (cl,cr)->(grads(gagePressure),grads(temperature)),
		  (cl,cr)->(gradv3d(u)),
		  (cl,cr)->alpha_diss,alpha_geom,
		  leftsP(gagePressure,minPg),rightsP(gagePressure,minPg),
		  leftsP(temperature,Zero),rightsP(temperature,Zero),
		  leftv3d(u),rightv3d(u),
		  facecenter,
		  Pambient,area,Rtilde,gamma,us_n,
		  SSF_Coeff),
    constraint(useSkewSymmetricFluxScheme,(cl,cr)->vol) {
    
    const vect3d an = $area.n ;
    
    // Now the upwind part
    // ------------------------------------------------------------------------
    const real pgL = $leftsP(gagePressure,minPg) ;
    const real pgR = $rightsP(gagePressure,minPg) ;
    const real tL = $leftsP(temperature,Zero) ;
    const real tR = $rightsP(temperature,Zero) ;
    const real rL = (pgL+$Pambient)/($Rtilde*tL) ;
    const real rR = (pgR+$Pambient)/($Rtilde*tR) ;
    const real al2 = $gamma*$Rtilde*tL ;
    const real ar2 = $gamma*$Rtilde*tR ;
    const real dp = 2.*fabs(pgL-pgR)/max(rL*al2,rR*ar2) ;
    const real ap = max(0.0,min(1.0,dp*1.0-0.5)) ;
    const real local_alpha = max(ap,real($alpha_geom)) ;
    const real alpha =
      max(max($cl->$alpha_diss,$cr->$alpha_diss),local_alpha) ;

    if(alpha >1e-10) {
      const real sada = $area.sada*alpha ;
      hllc_flux($iflux, pgL,tL,$leftv3d(u), pgR, tR, $rightv3d(u),
                an,sada,$Pambient,$Rtilde,$gamma,$us_n) ;
    } else {
      for(int i=0;i<5;++i)
	$iflux[i] = 0 ;
    }

    
    double CC = $SSF_Coeff/6.0 ;
    
    const real sada = $area.sada*(1.-alpha) ;

    const vect3d uf = 0.5*($cl->$u+$cr->$u) ;
    const real ufn = dot(uf,an) - $us_n ;
    
    const real pgf = 0.5*($cl->$gagePressure + $cr->$gagePressure) ;
    const real tf = 0.5*($cl->$temperature +$cr->$temperature) ;

    const real rf = (pgf+$Pambient)/($Rtilde*tf) ;
    const real mdot = rf*ufn*sada ;
    $iflux[0] += 2.*CC*mdot ;

    const int mi = 1 ;
    const real apgf = pgf*sada ;
    $iflux[mi+0] += 2.*CC*(mdot*uf.x + apgf*an.x) ;
    $iflux[mi+1] += 2.*CC*(mdot*uf.y + apgf*an.y) ;
    $iflux[mi+2] += 2.*CC*(mdot*uf.z + apgf*an.z) ;
    real e_internalf = $Rtilde*tf/($gamma-1) ;
    real ke_f = 0.5*dot(uf,uf) ;
    $iflux[4] += 2.*CC*(mdot*(ke_f+e_internalf) +
                       (ufn+$us_n)*(pgf+$Pambient)*sada );

    const vect3d dv = $facecenter -0.5*($cl->$cellcenter+$cr->$cellcenter) ;
    const vect3d dv2 = $cr->$cellcenter-$cl->$cellcenter ;

    vect3d ucor = 0.5*(dot($cl->$gradv3d(u),dv)+dot($cr->$gradv3d(u),dv)) ;
    vect3d ufc = uf+ucor ;

    real tlo = 0.25*tf ;
    real thi = 4*tf ;
    real pglo = 0.25*(pgf+$Pambient)-$Pambient ;
    real pghi = 4.*(pgf+$Pambient)-$Pambient ;

    real pgfc = pgf + 0.5*(dot($cl->$grads(gagePressure),dv)+
			   dot($cr->$grads(gagePressure),dv)) ;
    pgfc = max(pglo,min(pghi,pgfc)) ;

    real tfc = tf + 0.5*(dot($cl->$grads(temperature),dv)+
			 dot($cr->$grads(temperature),dv)) ;
    tfc = max(tlo,min(thi,tfc)) ;

    const real rfc = (pgfc+$Pambient)/($Rtilde*tfc) ;
    const real ufcn = dot(ufc,an) - $us_n ;

    const real mdotc = rfc*ufcn*sada ;
    $iflux[0] += mdotc ;

    const real apgfc = pgfc*sada ;
    $iflux[mi+0] += (mdotc*ufc.x + apgfc*an.x) ;
    $iflux[mi+1] += (mdotc*ufc.y + apgfc*an.y) ;
    $iflux[mi+2] += (mdotc*ufc.z + apgfc*an.z) ;
    real e_internalfc = $Rtilde*tfc/($gamma-1) ;
    real ke_fc = 0.5*dot(ufc,ufc) ;
    $iflux[4] += (mdotc*(ke_fc+e_internalfc) +
                  (ufcn+$us_n)*(pgfc+$Pambient)*sada );


    vect3d uf_l = $cr->$u-vect3d(dot(dv2,$cl->$gradv3d(u).x),
				 dot(dv2,$cl->$gradv3d(u).y),
				 dot(dv2,$cl->$gradv3d(u).z)) ;
    
    const real pgr = $cr->$gagePressure ;
    double pg_l = pgr-dot(dv2,$cl->$grads(gagePressure)) ;
    const real tr = $cr->$temperature ;
    double t_l = tr-dot(dv2,$cl->$grads(temperature)) ;
    pg_l = max(pglo,min(pghi,pg_l)) ;
    t_l = max(tlo,min(thi,t_l)) ;


    const real rf_l = (pg_l+$Pambient)/($Rtilde*t_l) ;
    const real ufn_l = dot(uf_l,an) - $us_n ;
    const real mdot_l = rf_l*ufn_l*sada ;
    $iflux[0] += -CC*mdot_l ;

    const real apgf_l = pg_l*sada ;
    $iflux[mi+0] += -CC*(mdot_l*uf_l.x + apgf_l*an.x) ;
    $iflux[mi+1] += -CC*(mdot_l*uf_l.y + apgf_l*an.y) ;
    $iflux[mi+2] += -CC*(mdot_l*uf_l.z + apgf_l*an.z) ;
    real e_internalf_l = $Rtilde*t_l/($gamma-1) ;
    real ke_f_l = 0.5*dot(uf_l,uf_l) ;
    $iflux[4] += -CC*(mdot_l*(ke_f_l+e_internalf_l) +
                      (ufn_l+$us_n)*(pg_l+$Pambient)*sada) ;    

    const real pgl = $cl->$gagePressure ;
    const real tl = $cl->$temperature ;
    vect3d uf_r = $cl->$u+vect3d(dot(dv2,$cr->$gradv3d(u).x),
                                 dot(dv2,$cr->$gradv3d(u).y),
                                 dot(dv2,$cr->$gradv3d(u).z)) ;
    double pg_r = pgl+dot(dv2,$cr->$grads(gagePressure)) ;
    double t_r = tl+dot(dv2,$cr->$grads(temperature)) ; 
    pg_r = max(pglo,min(pghi,pg_r)) ;
    t_r = max(tlo,min(thi,t_r)) ;

    const real rf_r = (pg_r+$Pambient)/($Rtilde*t_r) ;
    const real ufn_r = dot(uf_r,an) - $us_n ;
    const real mdot_r = rf_r*ufn_r*sada ;
    $iflux[0] += -CC*mdot_r ;

    const real apgf_r = pg_r*sada ;
    $iflux[mi+0] += -CC*(mdot_r*uf_r.x + apgf_r*an.x) ;
    $iflux[mi+1] += -CC*(mdot_r*uf_r.y + apgf_r*an.y) ;
    $iflux[mi+2] += -CC*(mdot_r*uf_r.z + apgf_r*an.z) ;
    real e_internalf_r = $Rtilde*t_r/($gamma-1) ;
    real ke_f_r = 0.5*dot(uf_r,uf_r) ;
    $iflux[4] += -CC*(mdot_r*(ke_f_r+e_internalf_r) +
                      (ufn_r+$us_n)*(pg_r+$Pambient)*sada) ;    


  }

  OUTPUT_SCALAR("cell2nodeMax(alpha_diss)",alpha) ;  
}

