//#############################################################################
//#
//# Copyright 2015, Mississippi State University
//#
//# This file is part of the flowPsi computational fluid dynamics solver.
//#
//# The flowPsi solver is free software: you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The flowPsi solver is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with the flowPsi solver.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################

#include <Loci.h>
#include "flowTypes.h"
#include <string>
#include "readGrid.h"
#include "Tools/stream.h"
#include "inviscidFlux.h"
#include "bcTools.h"
#include "flowPsiIO.h"
$include "flowPsi.lh"

namespace flowPsi {
  class isentropic_check : public BC_Check {
    string error_message ;
  public:
    std::string boundaryConditions() { return "isentropicInflow" ; }
    std::string variablesChecked() { return "T0,p0,mixture"; }
    bool checkOptions(const options_list &bc_options) {
      error_message = "" ;
      if(!bc_options.optionExists("p0") ||
         !bc_options.optionExists("T0")) {
        error_message = "both 'p0' and 'T0' are required" ;
        return false ;
      }
      bool check = true ;
      if(!check_scalar_units(bc_options,"p0","Pa")) {
        error_message= "Units are incompatible for 'p0' " ;
        check = false ;
      }
      if(!check_scalar_units(bc_options,"T0","K")) {
        error_message += "Units are incompatible for 'T0'";
        check = false ;
      }
      return check ;
    }
    std::ostream &ErrorMessage(std::ostream &s) {
      s << error_message << endl ;
      return s ;
    }
  } ;

  register_BC<isentropic_check> register_isentropic_check ;


  namespace  isentropic {
    void solve3x3System(Array<real,3> &x, 
			const Array<Array<real,3>,3> &A, 
			const Array<real,3> &b) {
      Array<Array<real,3>,3> Ainv ;
      real det = (A[0][0]*A[1][1]*A[2][2] + 
		  A[0][1]*A[1][2]*A[2][0] + 
		  A[0][2]*A[1][0]*A[2][1] - 
		  A[0][2]*A[1][1]*A[2][0] - 
		  A[0][0]*A[1][2]*A[2][1] - 
		  A[0][1]*A[1][0]*A[2][2]) ;
      real rdet = 1./det ;
      Ainv[0][0] = rdet*(A[1][1]*A[2][2]-A[1][2]*A[2][1]) ;
      Ainv[1][0] = rdet*(A[1][2]*A[2][0]-A[1][0]*A[2][2]) ;
      Ainv[2][0] = rdet*(A[1][0]*A[2][1]-A[1][1]*A[2][0]) ;
      
      Ainv[0][1] = rdet*(A[0][2]*A[2][1]-A[0][1]*A[2][2]) ;
      Ainv[1][1] = rdet*(A[0][0]*A[2][2]-A[0][2]*A[2][0]) ;
      Ainv[2][1] = rdet*(A[0][1]*A[2][0]-A[0][0]*A[2][1]) ;

      Ainv[0][2] = rdet*(A[0][1]*A[1][2]-A[0][2]*A[1][1]) ;
      Ainv[1][2] = rdet*(A[0][2]*A[1][0]-A[0][0]*A[1][2]) ;
      Ainv[2][2] = rdet*(A[0][0]*A[1][1]-A[0][1]*A[1][0]) ;
    
      x[0] = Ainv[0][0]*b[0]+Ainv[0][1]*b[1]+Ainv[0][2]*b[2] ;
      x[1] = Ainv[1][0]*b[0]+Ainv[1][1]*b[1]+Ainv[1][2]*b[2] ;
      x[2] = Ainv[2][0]*b[0]+Ainv[2][1]*b[1]+Ainv[2][2]*b[2] ;  
    }

    // Isentropic solution using pt primitive riemann from flow
    void isentropicSolve(real &pb, real &Tb, real &ub,
			 const real uni, const real pi, const real Ti,
			 const real p0, const real T0,
			 const vect3d &flowdir,
			 const vect3d &n,
			 const real Beta,
			 const real gamma,
			 const real Rtilde) {

      const real gm1 = gamma-1 ;
      const real a1 = Rtilde*gamma/gm1 ;
      const real h0 = a1*T0 ;
      const real s0 = a1*log(T0)-Rtilde*log(p0) ;
      const real a0 = sqrt(gamma*Rtilde*T0) ; 
      const real Tim = min(Ti,T0) ;

      const real ri = pi/(Rtilde*Tim) ;
      const real ai2 = gamma*Rtilde*Tim ;

      const real BM = Beta-1. ;
      const real unia = min(uni,a0) ;
      const real unil = (unia*dot(n,flowdir) <0)?-unia:unia ;
      const real sigmai = sqrt(unil*unil*BM*BM+4.*Beta*ai2) ;
      const real K3 = (2.*pi+ri*unil*(sigmai-BM*unil))/(2.*ri*sigmai) ;

      pb=min(p0,pi) ;
      Tb=min(T0,Ti) ;
      ub = uni/dot(n,flowdir) ;
      ub = min<real>(max<real>(ub,0.0),a0) ;
      if(pi > p0) { 
	ub = 0 ;
	return ;
      }

      for(int i=0;i<32;++i) {
	Array<Array<real,3>,3> A ;
	Array<real,3> b ;
	const real sb = a1*log(Tb) - Rtilde*log(pb);
	b[0] = s0-sb ;
	A[0][0] = -Rtilde/pb; // dsb/dpb
	A[0][1] = a1/Tb ;     // dsb/dTb
	A[0][2] = 0 ;
	b[1] = h0-(a1*Tb +.5*ub*ub) ;
	const real rp = 1./(Rtilde*Tb) ;
	const real rb = pb*rp ;
	const real rt = -pb*rp*Rtilde*rp ;
	const real rrho = 1./rb ;
	const real dhdP = rrho*((Tb*rt)*rrho+1.0) ;
	const real dhdT = a1 ;
	const real ab2 = gamma*Rtilde*Tb ;
	A[1][0] = dhdP ;
	A[1][1] = dhdT ;
	A[1][2] = ub ;
	const real f = dot(n,flowdir) ;
	const real unb = ub*f ;
	const real sigmab = sqrt(unb*unb*BM*BM+4.*Beta*ab2) ;
	const real K3b = (2.*pb+rb*unb*(sigmab-BM*unb))/(2.*rb*sigmab) ;
	b[2] = K3-K3b ;


	A[2][0] = (unb*(sigmab-BM*unb)*rp+2.)/(2.*rb*sigmab) - K3b*rp/rb ;
	A[2][1] = (unb*(sigmab-BM*unb)*rt)/(2.*rb*sigmab) - K3b*rt/rb ;
	const real dsigmadu = ub*BM*BM*f*f/sigmab ;
	A[2][2] = ((f*(sigmab-BM*unb)+unb*(dsigmadu-BM*f))/(2.*sigmab) -
		   K3b*dsigmadu/sigmab) ;

	Array<real,3> x ;
      
	solve3x3System(x,A, b) ;
      
	real alpha = 1.0 ;
	alpha = min(alpha,.75*pb/(max(-x[0],0.1*x[0])+1e-30)) ;
	alpha = min(alpha,.75*Tb/(max(-x[1],0.1*x[1])+1e-30)) ;

	pb += alpha*x[0] ;
	Tb += alpha*x[1] ;
	ub += alpha*x[2] ;
	pb = min(pb,p0) ;
	Tb = min(Tb,T0) ;
	ub = min(sqrt(ab2),ub) ;
	ub = max<real>(0,ub) ;
	if(fabs(x[1]) < T0*1e-8 && fabs(x[0]) < p0*1e-8 && 
	   fabs(x[2]) < a0*1e-7) {
	  return ;
	}
      }
      Loci::debugout << "isentropicInflow failed to converge!" << endl ;
      BCErrorCode |= flowPsi::ISENTROPIC_INFLOW_FAILED_CONVERGENCE ;
    }

  }

  $rule pointwise(u_f,gagePressure_f,temperature_f<-ci->u,
                  ci->temperature,ci->gagePressure,flow_direction,rigid_u,
                  p0Ref,T0Ref,Pambient,gamma,Rtilde,area),
    constraint(isentropicInflow_BC) {
    real p0 = $p0Ref ;
    real T0 = $T0Ref ;
    real uni = dot($ci->$u,$area.n) ;
    real pi = $ci->$gagePressure+$Pambient ;

    real pb, Tb, ubs ;
    const real Beta = 1.0 ;
    isentropic::isentropicSolve(pb,Tb,ubs,
				uni,pi,$ci->$temperature,
				p0,T0,$flow_direction,$area.n,
				Beta,$gamma,$Rtilde) ;
    vect3d ub = ubs*$flow_direction ;
    
    $u_f = ub ;
    $gagePressure_f = pb-$Pambient ;
    $temperature_f = Tb ;
  } 

  $rule pointwise(iflux<-area,gagePressure_f,temperature_f,u_f,Pambient,us_n,
		  gamma,Rtilde),
    constraint(isentropicInflow_BC) {
    inviscidFlux($iflux,$gagePressure_f,$temperature_f,$u_f,
		 $area.n,$area.sada,$Pambient,$Rtilde,$gamma,$us_n) ;
  }

  
    $rule apply(ci->srcJ<-leftsP(gagePressure,minPg),leftsP(temperature,Zero),leftv3d(u), gagePressure_f, temperature_f, u_f, area,us_n,Pambient,Rtilde,gamma,Eta_pf)[Loci::Summation],constraint(isentropicInflow_BC) {
    const real Tr = $temperature_f ;
    const real Pgr = $gagePressure_f ;
    const vect3d ur = $u_f ;
    const real Tl = $leftsP(temperature,Zero) ;
    const real Pgl = $leftsP(gagePressure,minPg) ;
    const vect3d ul = $leftv3d(u) ;

    real_fj tmp1[25] ;
    Mat<real_fj> fjp(&tmp1[0],5) ;
    fjp = mk_Scalar(0.) ;
    inviscidRiemannFjp(fjp,Pgl,Tl,ul,Pgr,Tr,ur,$area.n,$area.sada,$Pambient,
		       $Rtilde, $gamma,$us_n,$Eta_pf) ;

    for(int i=0;i<5;++i)
      for(int j=0;j<5;++j)
	$ci->$srcJ[i][j] -= fjp[i][j] ;

  }

  $rule pointwise(p0Ref<-ref->p0_BC) {
    $p0Ref = $ref->$p0_BC ;
  } 

  $rule pointwise(T0Ref<-ref->T0_BC) {
    $T0Ref = $ref->$T0_BC ;
  } 
  
}
