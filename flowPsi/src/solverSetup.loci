#include <Loci.h>
$include "flowPsi.lh"
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

namespace flowPsi {
  $rule unit(plot_status{n}),constraint(UNIVERSE{n}) {
    $plot_status{n} = 0 ;
  } 

  static double elapsed_check_time = -1 ;
  $type time_interval_check param<double>;
  $rule default(time_interval_check),comments("time interval to check for stop or plot file in seconds") {
    $time_interval_check = 240 ;
  }
  $rule apply(plot_status{n}<-ncycle{n},time_interval_check{n})[Loci::Maximum],prelude {
    if(Loci::MPI_rank == 0) {
      double ctime = MPI_Wtime() ;
      if(elapsed_check_time < 0)
        elapsed_check_time = ctime ;
      // Check every two minutes
      if(ctime-elapsed_check_time > *$time_interval_check{n}) {
        elapsed_check_time = ctime ;
        struct stat buf ;
        if(stat("plot",&buf)!=-1) {
          if(buf.st_size == 0 && S_ISREG(buf.st_mode)) {
            if(::unlink("plot")!= -1)
              join(*$plot_status{n},1) ;
          }
        }
        if(stat("stop",&buf)!=-1) {
          if(buf.st_size == 0 && S_ISREG(buf.st_mode)) {
            if(::unlink("stop")!= -1)
              join(*$plot_status{n},2) ;
          }
        }
      }
    }
  } ;


  
  $rule optional(maximumRunTime),comments("Maximum wallclock time for run.  If this time is exceeded, flowpsi will dump restart files and terminate") {
    $maximumRunTime = 0.0 ;
  } 

  extern double StartTime ;
  
  $rule apply(plot_status{n}<-ncycle{n},maximumRunTime)[Loci::Maximum],prelude {
    double currTime = MPI_Wtime() ;
    double elapsedTime = currTime - flowPsi::StartTime ;
    double maxTime = *$maximumRunTime ;
    if(elapsedTime > maxTime)
      join(*$plot_status{n},2) ;
  } ;
  

  // Compute eigenvalues for cfl estimation
  $type maxev_f store<real> ;

  $rule pointwise(maxev_f<-area,us_n,(cl,cr)->(u,soundSpeed)) {
    $maxev_f = max(fabs(dot($cl->$u,$area.n)-$us_n)+$cl->$soundSpeed,
                   fabs(dot($cr->$u,$area.n)-$us_n)+$cr->$soundSpeed) ;
  }
  $rule pointwise(maxev_f<-area,us_n,u_f,soundSpeed_f),constraint(ci->u) {
    $maxev_f = fabs(dot($u_f,$area.n)-$us_n)+$soundSpeed_f ;
  }
  
  $rule pointwise(cflpdt<-vol,(upper,lower,boundary_map)->(maxev_f,area)) {
    real meva = 0.0 ;
    for(const int *li=$lower.begin();li!=$lower.end();++li) {
      meva += li->$maxev_f*li->$area.sada ;
    }
    for(const int *ui=$upper.begin();ui!=$upper.end();++ui) {
      meva += ui->$maxev_f*ui->$area.sada ;
    }
    for(const int *bi=$boundary_map.begin();bi!=$boundary_map.end();++bi) {
      meva += bi->$maxev_f*bi->$area.sada ;
    }
    $cflpdt = 0.5*meva/$vol; // Area counted twice so divide by 2
  }

  // Define maxmin operator
  template <class T> struct MaxMin {
    void operator()(T &r, const T &s) {
      r.first = max(r.first,s.first) ;
      r.second = min(r.second,s.second) ;
    }
  } ;

  $rule unit(cfl),constraint(geom_cells) {
    $cfl.first = real(0.0) ;    //base value for cflmax
    $cfl.second = real(1e30) ;   //base value for cflmin
  }

  $rule apply(cfl<-cflpdt,dtau,iblank)[MaxMin],
    constraint(timeStepSteadyState,cflpdt) {
    std::pair<real,real> CFL ;
    if($iblank < 2) {
      CFL.first = $cflpdt*$dtau ;
      CFL.second = CFL.first ;
      join($cfl,CFL) ;
    }
  }

  $rule apply(cfl<-cflpdt,dtmax,iblank)[MaxMin],
    constraint(timeStepAccurate,cflpdt) {
    std::pair<real,real> CFL ;
    if($iblank < 2) {
      CFL.first = $cflpdt*$dtmax ;
      CFL.second = CFL.first ;
      join($cfl,CFL) ;
    }
  }

  // provides the condition under which cfl number is printed
  $rule default(print_freq) {
    $print_freq = 10 ;
  }

  $type do_print_cfl param<bool> ;
  
  $rule singleton(do_print_cfl{n,it}<-ncycle{n},print_freq,$it{n,it}) {
    //the condition for dumping out cfl information
    // print out cfl when we are dumping an output file (ncyc % print_freq) == 0
    // and we are on the first newton iteration
    $do_print_cfl{n,it} = ($ncycle{n} % $print_freq) == 0 && ($$it{n,it} == 0) ;
  }

  //Dump cfl
  $rule singleton(OUTPUT{n,it}<-cfl{n,it}),
    conditional(do_print_cfl{n,it}),option(disable_threading) {
    // rules that produce output in some form have OUTPUT as a target variable
    // The existence of the OUTPUT variable ensures that the rule will be
    // scheduled, even though it is not needed to perform the calculation
    // (i.e. not part of the deduction)
    if(Loci::MPI_rank==0) {
      using std::cout ;
      using std::endl ;
      cout.precision(5) ;
      cout << " cflmax = " << $cfl{n,it}.first
           << " cflmin = " << $cfl{n,it}.second << endl ;
    }
  }

   
    
  
}
