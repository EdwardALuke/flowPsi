#include <Loci.h>
$include "flowPsi.lh"

namespace flowPsi {
  using std::cerr ;
  using std::endl ;

  // Initialize newton to past timestep value
  $rule pointwise(temperature{n,it=0}<-temperature{n}),
    constraint(geom_cells) {
    $temperature{n,it=0}= $temperature{n} ;
  }
  $rule pointwise(gagePressure{n,it=0}<-gagePressure{n}),
    constraint(geom_cells) {
    $gagePressure{n,it=0} = $gagePressure{n} ;
  }
  $rule pointwise(u{n,it=0}<-u{n}),
    constraint(geom_cells) {
    $u{n,it=0} = $u{n} ;
  }

  $type dfluid storeVec<real> ;
  $rule pointwise(temperature{n,it+1},gagePressure{n,it+1},u{n,it+1}<- 
		  temperature{n,it},gagePressure{n,it},u{n,it},dfluid{n,it},
		  Pambient),
		  inplace(temperature{n,it+1}|temperature{n,it}),
		  inplace(gagePressure{n,it+1}|gagePressure{n,it}),
    inplace(u{n,it+1}|u{n,it}),constraint(geom_cells,timeStepSteadyState) {
    const real dT = $dfluid{n,it}[0] ;
    const vect3d du($dfluid{n,it}[1],$dfluid{n,it}[2],$dfluid{n,it}[3]) ;
    const real dp = $dfluid{n,it}[4] ;
    real alpha = 1.0 ;
    alpha = min(alpha,0.9*$temperature{n,it}/(fabs(dT)+1e-30)) ;
    alpha = min(alpha,0.9*($gagePressure{n,it}+$Pambient)/(fabs(dp)+1e-30)) ;
    $temperature{n,it+1} = $temperature{n,it} + alpha*dT;
    $gagePressure{n,it+1} = $gagePressure{n,it} + alpha*dp ;
    $u{n,it+1} = $u{n,it} + alpha*du ;
  }


  $rule pointwise(temperature{n+1},gagePressure{n+1},u{n+1}<-
		  temperature{n,it},gagePressure{n,it},u{n,it}),
    inplace(temperature{n+1}|temperature{n,it}),
    inplace(gagePressure{n+1}|gagePressure{n,it}),
    inplace(u{n+1}|u{n,it}),
    constraint(geom_cells,timeStepSteadyState),
    conditional(newtonFinished{n,it}), prelude { } ;
  
  $rule pointwise(temperature{n,it+1},gagePressure{n,it+1},u{n,it+1}<- 
		  temperature{n,it},gagePressure{n,it},u{n,it},dfluid{n,it},
                  localPBias{n,it},
		  Pambient),
    inplace(temperature{n,it+1}|temperature{n,it}),
    inplace(gagePressure{n,it+1}|gagePressure{n,it}),
    inplace(u{n,it+1}|u{n,it}),
    constraint(geom_cells,timeStepAccurate) {
    const real dT = $dfluid{n,it}[0] ;
    const vect3d du($dfluid{n,it}[1],$dfluid{n,it}[2],$dfluid{n,it}[3]) ;
    const real dp = $dfluid{n,it}[4] ;
    real alpha = 1.0 ;
    const real T_factor = 2.0 ;
    const real relax = 0.8 ;
    alpha = min(alpha,0.9*$temperature{n,it}/(fabs(T_factor*dT)+1e-30)) ;
    const real peps = $localPBias{n,it} ;
    const real P_factor = (2.-peps) ;
    alpha = min(alpha,relax*($gagePressure{n,it}+$Pambient)/(fabs(P_factor*dp)+1e-30)) ;
    $temperature{n,it+1} = $temperature{n,it} + alpha*dT;
    $gagePressure{n,it+1} = $gagePressure{n,it} + alpha*dp ;
    $u{n,it+1} = $u{n,it} + alpha*du ;
  }


  $rule pointwise(temperature{n+1},gagePressure{n+1},u{n+1}<-
		  temperature{n,it},gagePressure{n,it},u{n,it},
                  temperature{n},gagePressure{n},u{n},
                  localPBias{n,it},Pambient,Rtilde),
    inplace(temperature{n+1}|temperature{n,it}),
    inplace(gagePressure{n+1}|gagePressure{n,it}),
    inplace(u{n+1}|u{n,it}),
    constraint(geom_cells,timeStepAccurate),
    conditional(newtonFinished{n,it}) {
    const real Tstar = $temperature{n,it} ;
    const real pgstar = $gagePressure{n,it} ;
    const real Tnp1 = (2.*Tstar - $temperature{n}) ;
    const real peps = $localPBias{n,it} ;
    const real pgnp1 = (2.*pgstar-(1.-peps)*$gagePressure{n})/(1+peps) ;
    
    const real rhon = ($gagePressure{n}+$Pambient)/($Rtilde*$temperature{n}) ;
    const real rhonp = (pgnp1+$Pambient)/($Rtilde*Tnp1) ;

    const real srhonp = sqrt(rhonp) ;
    const real srhon = sqrt(rhon) ;
    const real w1 = (srhonp+srhon)/srhonp ;
    const real w2 = srhon/srhonp ;
    
    vect3d unp1 = w1*$u{n,it}-w2*$u{n} ;
    $gagePressure{n+1} = pgnp1 ;
    $temperature{n+1} = Tnp1 ;
    $u{n+1} = unp1 ;
  } 

  $type newtonMaxIter param<int> ;
  $rule default(newtonMaxIter) {
    $newtonMaxIter = 6 ;
  }

  $type newtonFinalIter param<int> ;
  
  $rule singleton(newtonFinalIter<-newtonMaxIter,timeSteppingMode) {
    $newtonFinalIter = 1 ;
    if($timeSteppingMode > 0)
      $newtonFinalIter=$newtonMaxIter ;
  }
  
  $type newtonFinished param<bool> ;
  $rule singleton(newtonFinished{n,it}<-$it{n,it},newtonFinalIter) {
    $newtonFinished{n,it} = ($$it{n,it} >= $newtonFinalIter) ;
  }

  $type fluidLinearSolver param<std::string> ;
  $rule default(fluidLinearSolver),
    comments("Select the type of linear solver to use when solving the mean flow equations. Options are 'sgs' for symmetric gauss seidel, 'fsgs' for a fast symmetric gauss seidel that uses more memory, 'lsgs' for a robustline symmetric gauss seidel solver, or 'petsc' for the petsc GMRES solver. The default is 'lsgs'") 
  {
    $fluidLinearSolver = "lsgs" ;
  }

  $type fluidLinearSolverSGS Constraint ;
  $type fluidLinearSolverFSGS Constraint ;
  $type fluidLinearSolverLSGS Constraint ;
  $type fluidLinearSolverPETSC Constraint ;

  $rule constraint(fluidLinearSolverSGS,fluidLinearSolverLSGS,fluidLinearSolverFSGS,
		fluidLinearSolverPETSC<-fluidLinearSolver) {
    $fluidLinearSolverSGS = EMPTY ;
    $fluidLinearSolverFSGS = EMPTY ;
    $fluidLinearSolverLSGS = EMPTY ;
    $fluidLinearSolverPETSC = EMPTY ;
    if($fluidLinearSolver == "petsc") {
#ifndef USE_PETSC
      cerr << "petsc not installed!" << endl ;
      Loci::Abort() ;
#endif
      $fluidLinearSolverPETSC = ~EMPTY ;
    } else if ($fluidLinearSolver == "lsgs") {
      $fluidLinearSolverLSGS = ~EMPTY ;
    } else if ($fluidLinearSolver == "fsgs") {
      $fluidLinearSolverFSGS = ~EMPTY ;
    } else {
      $fluidLinearSolverSGS = ~EMPTY ;
    }
  }
	 

  $type SGSBlockedSSolve(fluid) storeVec<real> ;
  $rule pointwise(dfluid<-SGSBlockedSSolve(fluid)),
    constraint(geom_cells,fluidLinearSolverSGS),
    inplace(dfluid|SGSBlockedSSolve(fluid)) {}

  $type LSGSBlockedSSolve(fluid,fluid_B) storeVec<real> ;
  $rule pointwise(dfluid<-LSGSBlockedSSolve(fluid,fluid_B)),
    constraint(geom_cells,fluidLinearSolverLSGS),
    inplace(dfluid|LSGSBlockedSSolve(fluid,fluid_B)) {}

  $type FSGSBlockedSSolve(fluid) storeVec<real> ;
  $rule pointwise(dfluid<-FSGSBlockedSSolve(fluid)),
    constraint(geom_cells,fluidLinearSolverFSGS),
    inplace(dfluid|FSGSBlockedSSolve(fluid)) {}

  $type petscBlockedSSolve(fluid) storeVec<real> ;
  $rule pointwise(dfluid<-petscBlockedSSolve(fluid)), 
    constraint(geom_cells,fluidLinearSolverPETSC),
    inplace(dfluid|petscBlockedSSolve(fluid)){} 


}
