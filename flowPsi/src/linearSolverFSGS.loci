//#############################################################################
//#
//# Copyright 2015-2019, Mississippi State University
//#
//# This file is part of the flowPsi computational fluid dynamics solver.
//#
//# The flowPsi solver is free software: you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation, either version 3 of the License, or
//# (at your option) any later version.
//#
//# The flowPsi solver is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//#
//# You should have received a copy of the GNU General Public License
//# along with the flowPsi solver.  If not, see <http://www.gnu.org/licenses>
//#
//#############################################################################

#include <Loci.h>
#include <vector> 
#include <algorithm>
#include <set>
#include "flowTypes.h"
$include "flowPsi.lh"



// Scalar solver using modified line gauss seidel method
namespace FGSI {
#ifdef USE_AUTODIFF
#ifdef AUTODIFF2ND
#define FSGS_TYPE Loci::MPI_FADD2
#else
#define FSGS_TYPE Loci::MPI_FADD 
#endif
#else	
#define FSGS_TYPE MPI_DOUBLE
#endif
  using flowPsi::real ;
  using flowPsi::realF ;
  using flowPsi::real_fj ;
  using std::vector ;
  using std::sort ;
  using std::swap ;
  using std::set ;
  using std::endl ;
  using std::cerr ;
  using std::cout ;

  template < int N, class T1, class T2, class T3 > 
  inline void dotprod_accum_N(const T1* const restrict A,
			      const T2* const restrict vin,
			      T3 *restrict vo) {
#ifdef HAVE_IVDEP
#pragma vector unaligned
#endif
    for(int j=0;j<N;++j) {
      const T2 in = vin[j] ;
      const T1 * restrict Aj = A+N*j ;
#ifdef HAVE_IVDEP
#pragma ivdep
#pragma vector unaligned
#endif
      for(int i=0;i<N;++i)
	vo[i] += (Aj[i])*in ;
    }
  }  


  template<int N,class T1, class T2, class T3>
  inline void solve_lu_N(const T1 * restrict A,
                       const T2 *restrict b,
                       T3 *restrict x) {
    // Perform forward solve Ly = b, note b becomes y after this step           
#ifdef HAVE_IVDEP
#pragma vector unaligned
#endif
    for(int i=0;i<N;++i) {
      T3 tmp = b[i] ;
      const T1 * restrict Aij = A+i ;
#ifdef HAVE_IVDEP
#pragma vector unaligned
#endif
      for(int j=0;j<i;++j,Aij+=N)
        tmp -= *Aij*x[j] ;
      x[i] = tmp ;
    }
    // Do back solve Ux = y
    const T1 *restrict Ai = A + N*(N-1) ;
#ifdef HAVE_IVDEP
#pragma vector unaligned
#endif
    for(int i=N-1;i>=0;--i,Ai-=N) {
      const T1 *restrict Aj = Ai + N ;
      T3 tmp = x[i] ;
#ifdef HAVE_IVDEP
#pragma vector unaligned
#endif
      for(int j=i+1;j<N;++j,Aj+=N)
	tmp -= Aj[i]*x[j] ;
      x[i] = tmp/Ai[i] ;
    }
  }

  template<>
#if defined (__INTEL_COMPILER)
  __forceinline
#else
  __attribute__ ((always_inline))
#endif
  inline void solve_lu_N<9,float,double,double>(const float * restrict A,
                       const double *restrict b,
                       double *restrict x) {
    // Perform forward solve Ly = b, note b becomes y after this step           
#if 0 && defined (__INTEL_COMPILER) && defined (__SSE4_1__)
    __m128  a0,a1,a2,a3,a4;
    __m128d b0,b1,Ax0,Ax1,Ax2,Ax3,Ax4,Ax5,Ax6,Ax7;
    __m128d x0,x1,x2,x3,x4,x5,x6,x7,x8;
    __m128d s0,s1,s2,s3;
    x[0] = -b[0];

    b0  = _mm_sub_pd(_mm_setzero_pd(), _mm_loadu_pd(b+1));
    a0  = _mm_loadu_ps(A+1); Ax0 = _mm_cvtps_pd(a0);
    x0  = _mm_set1_pd(x[0]);
    Ax0 = _mm_mul_pd(Ax0,x0);
          _mm_storeu_pd(&x[1], _mm_sub_pd(b0,Ax0));
    x[2]= x[2] - A[11]*x[1];

    b1  = _mm_sub_pd(_mm_setzero_pd(), _mm_loadu_pd(b+3));
    Ax0 = _mm_cvtps_pd(_mm_shuffle_ps(a0,a0,0xEE));
    a1  = _mm_loadu_ps(A+12); Ax1 = _mm_cvtps_pd(a1);
    a2  = _mm_loadu_ps(A+21); Ax2 = _mm_cvtps_pd(a2);
    x1  = _mm_set1_pd(x[1]);
    x2  = _mm_set1_pd(x[2]);
    Ax0 = _mm_mul_pd(Ax0,x0);
    Ax1 = _mm_mul_pd(Ax1,x1);
    Ax2 = _mm_mul_pd(Ax2,x2);
          _mm_storeu_pd(&x[3], _mm_sub_pd(b1,_mm_add_pd(_mm_add_pd(Ax0,Ax1),Ax2)));
    x[4]= x[4] - A[31]*x[3];

    b0  = _mm_sub_pd(_mm_setzero_pd(), _mm_loadu_pd(b+5));
    a0  = _mm_loadu_ps(A+5); Ax0 = _mm_cvtps_pd(a0);
    Ax1 = _mm_cvtps_pd(_mm_shuffle_ps(a1,a1,0xEE));
    Ax2 = _mm_cvtps_pd(_mm_shuffle_ps(a2,a2,0xEE));
    a3  = _mm_loadu_ps(A+32); Ax3 = _mm_cvtps_pd(a3);
    a4  = _mm_loadu_ps(A+41); Ax4 = _mm_cvtps_pd(a4);

    x3  = _mm_set1_pd(x[3]);
    x4  = _mm_set1_pd(x[4]);
    Ax0 = _mm_mul_pd(Ax0,x0);
    Ax1 = _mm_mul_pd(Ax1,x1);
    s0  = _mm_add_pd(Ax0,Ax1);

    Ax2 = _mm_mul_pd(Ax2,x2);
    Ax3 = _mm_mul_pd(Ax3,x3);
    s1  = _mm_add_pd(Ax2,Ax3);
    Ax4 = _mm_mul_pd(Ax4,x4);
          _mm_storeu_pd(&x[5], _mm_sub_pd(b0,_mm_add_pd(_mm_add_pd(s0,s1),Ax4)));
    x[6]= x[6] - A[51]*x[5];

    b1  = _mm_sub_pd(_mm_setzero_pd(), _mm_loadu_pd(b+7));
    Ax0 = _mm_cvtps_pd(_mm_shuffle_ps(a0,a0,0xEE));
    Ax1 = _mm_cvtps_pd(_mm_loadu_ps(A+16));
    Ax2 = _mm_cvtps_pd(_mm_loadu_ps(A+25));
    Ax3 = _mm_cvtps_pd(_mm_shuffle_ps(a3,a3,0xEE));
    Ax4 = _mm_cvtps_pd(_mm_shuffle_ps(a4,a4,0xEE));
    Ax5 = _mm_cvtps_pd(_mm_loadu_ps(A+52));
    Ax6 = _mm_cvtps_pd(_mm_loadu_ps(A+61));
    x5  = _mm_set1_pd(x[5]);
    x6  = _mm_set1_pd(x[6]);

    Ax0 = _mm_mul_pd(Ax0,x0);
    Ax1 = _mm_mul_pd(Ax1,x1);
    s0  = _mm_add_pd(Ax0,Ax1);

    Ax2 = _mm_mul_pd(Ax2,x2);
    Ax3 = _mm_mul_pd(Ax3,x3);
    s1  = _mm_add_pd(Ax2,Ax3);

    Ax4 = _mm_mul_pd(Ax4,x4);
    Ax5 = _mm_mul_pd(Ax5,x5);
    s2  = _mm_add_pd(Ax4,Ax5);
    s3  = _mm_add_pd(s0,s1);
    Ax6 = _mm_mul_pd(Ax6,x6);
          _mm_storeu_pd(&x[7], _mm_sub_pd(b1,_mm_add_pd(_mm_add_pd(s2,s3),Ax6)));
    x[8]= x[8] - A[71]*x[7];
#else
#if 0
#ifdef HAVE_IVDEP
#pragma vector unaligned
#endif
    for(int i=0;i<9;++i) {
      double tmp = -b[i] ;
      const float * restrict Aij = A+i ;
#ifdef HAVE_IVDEP
#pragma vector unaligned
#endif
      for(int j=0;j<i;++j,Aij+=9) {
        tmp -= *Aij*x[j] ;
      }
      x[i] = tmp ;
    }
#else
    x[0] = -b[0];

    x[1] = -b[1] - A[1]*x[0];
    x[2] = -b[2] - A[2]*x[0] - A[11]*x[1];

    x[3] = -b[3] - A[3]*x[0] - A[12]*x[1] - A[21]*x[2];
    x[4] = -b[4] - A[4]*x[0] - A[13]*x[1] - A[22]*x[2] - A[31]*x[3];

    x[5] = -b[5] - A[5]*x[0] - A[14]*x[1] - A[23]*x[2] - A[32]*x[3] - A[41]*x[4];
    x[6] = -b[6] - A[6]*x[0] - A[15]*x[1] - A[24]*x[2] - A[33]*x[3] - A[42]*x[4] - A[51]*x[5];

    x[7] = -b[7] - A[7]*x[0] - A[16]*x[1] - A[25]*x[2] - A[34]*x[3] - A[43]*x[4] - A[52]*x[5] - A[61]*x[6];
    x[8] = -b[8] - A[8]*x[0] - A[17]*x[1] - A[26]*x[2] - A[35]*x[3] - A[44]*x[4] - A[53]*x[5] - A[62]*x[6] - A[71]*x[7];
#endif
#endif

    // Do back solve Ux = y
#if 0 && defined (__INTEL_COMPILER) && defined (__SSE4_1__)
    __m128 div;
    __m128d Ax67,Ax45,Ax23,Ax01,one=_mm_set_pd(1.,1.);
    double d[2], sum[2];
    x[8] = (x[8]) / A[80];
    x8   = _mm_set1_pd(x[8]);

    div  = _mm_set_ps(A[70], A[60], A[50], A[40]) ;
    a0   = _mm_loadu_ps(A+76);
    Ax67 = _mm_cvtps_pd(_mm_shuffle_ps(a0,a0,0xEE));
    Ax67 = _mm_mul_pd(Ax67,x8);
           _mm_store_pd(&sum[0], Ax67);
           _mm_store_pd(&d[0], _mm_div_pd(one,_mm_cvtps_pd(_mm_shuffle_ps(div,div,0xEE))));
    x[7] = (x[7]              - sum[1])*d[1];
    x[6] = (x[6] - A[69]*x[7] - sum[0])*d[0];
    x7   = _mm_set1_pd(x[7]);
    x6   = _mm_set1_pd(x[6]);

    a1   = _mm_loadu_ps(A+72);
    Ax45 = _mm_mul_pd(_mm_cvtps_pd(a0),x8);
    Ax23 = _mm_mul_pd(_mm_cvtps_pd(_mm_shuffle_ps(a1,a1,0xEE)),x8);
    Ax01 = _mm_mul_pd(_mm_cvtps_pd(a1),x8);

    a2   = _mm_loadu_ps(A+63);
    a0   = _mm_loadu_ps(A+67);
    Ax45 = _mm_add_pd(Ax45, _mm_mul_pd(_mm_cvtps_pd(a0),x7));
    Ax23 = _mm_add_pd(Ax23, _mm_mul_pd(_mm_cvtps_pd(_mm_shuffle_ps(a2,a2,0xEE)),x7));
    Ax01 = _mm_add_pd(Ax01, _mm_mul_pd(_mm_cvtps_pd(a2),x7));

    a1   = _mm_loadu_ps(A+54);
    a2   = _mm_loadu_ps(A+58);
    Ax45 = _mm_add_pd(Ax45, _mm_mul_pd(_mm_cvtps_pd(a2),x6));
    Ax23 = _mm_add_pd(Ax23, _mm_mul_pd(_mm_cvtps_pd(_mm_shuffle_ps(a1,a1,0xEE)),x6));
    Ax01 = _mm_add_pd(Ax01, _mm_mul_pd(_mm_cvtps_pd(a1),x6));
           _mm_store_pd(&sum[0], Ax45);
           _mm_store_pd(&d[0], _mm_div_pd(one,_mm_cvtps_pd(div)));
    x[5] = (x[5]              - sum[1])*d[1];
    x[4] = (x[4] - A[49]*x[5] - sum[0])*d[0];
    x5   = _mm_set1_pd(x[5]);
    x4   = _mm_set1_pd(x[4]);

    div  = _mm_set_ps(A[30], A[20], A[10], A[ 0]) ;
    a0   = _mm_loadu_ps(A+45);
    a1   = _mm_loadu_ps(A+36);
    Ax23 = _mm_add_pd(Ax23, _mm_mul_pd(_mm_cvtps_pd(_mm_shuffle_ps(a0,a0,0xEE)),x5));
    Ax01 = _mm_add_pd(Ax01, _mm_mul_pd(_mm_cvtps_pd(a0),x5));
    Ax23 = _mm_add_pd(Ax23, _mm_mul_pd(_mm_cvtps_pd(_mm_shuffle_ps(a1,a1,0xEE)),x4));
    Ax01 = _mm_add_pd(Ax01, _mm_mul_pd(_mm_cvtps_pd(a1),x4));
           _mm_store_pd(&sum[0], Ax23);
           _mm_store_pd(&d[0], _mm_div_pd(one,_mm_cvtps_pd(_mm_shuffle_ps(div,div,0xEE))));
    x[3] = (x[3]              - sum[1])*d[1];
    x[2] = (x[2] - A[29]*x[3] - sum[0])*d[0];
    x3   = _mm_set1_pd(x[3]);
    x2   = _mm_set1_pd(x[2]);

    a0   = _mm_loadu_ps(A+27);
    a1   = _mm_loadu_ps(A+18);
    Ax01 = _mm_add_pd(Ax01, _mm_mul_pd(_mm_cvtps_pd(a0),x3));
    Ax01 = _mm_add_pd(Ax01, _mm_mul_pd(_mm_cvtps_pd(a1),x2));
           _mm_store_pd(&sum[0], Ax01);
           _mm_store_pd(&d[0], _mm_div_pd(one,_mm_cvtps_pd(div)));
    x[1] = (x[1]              - sum[1])*d[1];
    x[0] = (x[0] - A[ 9]*x[1] - sum[0])*d[0];
#else
#if 0
    const float *restrict Ai = A + 9*(9-1) ;
#ifdef HAVE_IVDEP
#pragma vector unaligned
#endif
    for(int i=9-1;i>=0;--i,Ai-=9) {
      const float *restrict Aj = Ai + 9 ;
      double tmp = x[i] ;
#ifdef HAVE_IVDEP
#pragma vector unaligned
#endif
      for(int j=i+1;j<9;++j,Aj+=9) {
	    tmp -= Aj[i]*x[j] ;
      }
      x[i] = tmp/Ai[i] ;
    }
#else
        x[8] = (                                                                                        x[8]) / A[80];

        x[7] = (                                                                             x[7]-A[79]*x[8]) / A[70];
        x[6] = (                                                                  x[6]-A[69]*x[7]-A[78]*x[8]) / A[60];

        x[5] = (                                                       x[5]-A[59]*x[6]-A[68]*x[7]-A[77]*x[8]) / A[50];
        x[4] = (                                            x[4]-A[49]*x[5]-A[58]*x[6]-A[67]*x[7]-A[76]*x[8]) / A[40];

        x[3] = (                                 x[3]-A[39]*x[4]-A[48]*x[5]-A[57]*x[6]-A[66]*x[7]-A[75]*x[8]) / A[30];
        x[2] = (                      x[2]-A[29]*x[3]-A[38]*x[4]-A[47]*x[5]-A[56]*x[6]-A[65]*x[7]-A[74]*x[8]) / A[20];

        x[1] = (           x[1]-A[19]*x[2]-A[28]*x[3]-A[37]*x[4]-A[46]*x[5]-A[55]*x[6]-A[64]*x[7]-A[73]*x[8]) / A[10];
        x[0] = (x[0]-A[ 9]*x[1]-A[18]*x[2]-A[27]*x[3]-A[36]*x[4]-A[45]*x[5]-A[54]*x[6]-A[63]*x[7]-A[72]*x[8]) / A[ 0];
#endif
#endif
  }

  using std::vector ;
  using std::sort ;
  using std::swap ;
  using std::set ;
  using Loci::realToDouble ;
  using Loci::realToFloat ;
  
#ifdef USE_AUTODIFF
  typedef Loci::real_t real ;
  typedef Loci::real_t realF ;
#ifdef AUTODIFF2ND
#define FSGS_TYPE Loci::MPI_FADD2
#else
#ifdef MULTIFAD
#define FSGS_TYPE Loci::MPI_MFADD  
#else  
#define FSGS_TYPE Loci::MPI_FADD
#endif
#endif
#else	
  typedef double real ;
  typedef float realF ;
#define FSGS_TYPE MPI_DOUBLE
#endif


  // Scalar solve
  $type X_B store<real> ;
  $type X_D store<real> ;
  $type X_L store<real> ;
  $type X_U store<real> ;

  $type FSGSMatrixName(X) param<std::string> ;
  $rule singleton(FSGSMatrixName(X)),constraint(UNIVERSE),
    	option(disable_threading) {
    const Loci::rule_impl::info &info = get_info() ;
    Loci::variableSet outset = info.output_vars() ;
    Loci::variable out=*outset.begin() ;
    string name = "X" ;
    // Scan forward for first underscore
    if(out.get_arg_list().size() != 1) {
      cerr << "unexpected fault"<< endl 
	   << "variable " << out 
	   << " should be FSGSMatrixName(X)!" << endl ;
      Loci::Abort() ;
    }
    Loci::variable varg = Loci::variable(out.get_arg_list()[0]) ;
    const Loci::variable::info vinfo = varg.get_info() ;
    name = vinfo.name ;
    $FSGSMatrixName(X) = name ;
  }

  $type FSGSDiagnosticLevel param<int> ;

  $type FSGSSolverControls param<Loci::options_list> ;
  $rule default(FSGSSolverControls) {
  }
  
  $rule default(FSGSDiagnosticLevel) {
    $FSGSDiagnosticLevel = 0 ;
  }

  $type FSGSDiagnosticLevel(X) param<int> ;
  $rule singleton(FSGSDiagnosticLevel(X)<-FSGSMatrixName(X),FSGSDiagnosticLevel,
                  FSGSSolverControls) {
    using namespace Loci ;
    $FSGSDiagnosticLevel(X) = $FSGSDiagnosticLevel ;
    string name = $FSGSMatrixName(X) ;
    if($FSGSSolverControls.optionExists(name)) {
      option_value_type vt = $FSGSSolverControls.getOptionValueType(name) ;
      option_values ov = $FSGSSolverControls.getOption(name) ;
      options_list::arg_list value_list ;
      switch(vt) {
      case FUNCTION:
        {
          ov.get_value(value_list) ;
          options_list ol ;
          ol.Input(value_list) ;
          string setting = "DiagnosticLevel" ;
          if(ol.optionExists(setting)) {
            real val = $FSGSDiagnosticLevel(X) ;
            ol.getOption(setting,val) ;
            $FSGSDiagnosticLevel(X) = int(floor(val + 0.5)) ;
          }
        }
      default:
        break ;
      }
    }
  }

  $type gauss_seidel_iter param<int> ;
  $type FSGSMaxIter(X) param<int> ;
  $rule singleton(FSGSMaxIter(X)<-FSGSMatrixName(X),gauss_seidel_iter,
                  FSGSSolverControls) {
    using namespace Loci ;
    $FSGSMaxIter(X) = $gauss_seidel_iter ;
    string name = $FSGSMatrixName(X) ;
    if($FSGSSolverControls.optionExists(name)) {
      option_value_type vt = $FSGSSolverControls.getOptionValueType(name) ;
      option_values ov = $FSGSSolverControls.getOption(name) ;
      options_list::arg_list value_list ;
      switch(vt) {
      case FUNCTION:
        {
          ov.get_value(value_list) ;
          options_list ol ;
          ol.Input(value_list) ;
          string setting = "MaxIter" ;
          if(ol.optionExists(setting)) {
            real val = $FSGSMaxIter(X) ;
            ol.getOption(setting,val) ;
            $FSGSMaxIter(X) = int(floor(val + 0.5)) ;
          }
        }
      default:
        break ;
      }
    }
  }

  $type FSGSmatrixInitialize blackbox<int> ;

  $type FSGSmatrixPeriodic blackbox<std::vector<pair<int,int> > > ;

  $rule unit(FSGSmatrixPeriodic),constraint(UNIVERSE),prelude {
    $FSGSmatrixPeriodic = vector<pair<int,int> >() ;
  } ;

  $rule apply(FSGSmatrixPeriodic)[Loci::NullOp],constraint(geom_cells), prelude { } ;
  
  $rule apply(FSGSmatrixPeriodic<-cr->fileNumber(cellcenter),pmap->cl->fileNumber(cellcenter))[Loci::NullOp], option(disable_threading), prelude {
    Loci::entitySet pset = Loci::entitySet(seq) ;
    FORALL(pset,ii) {
      int i1 = $cr[ii] ;
      int i2 = $cl[$pmap[ii]] ;
      ($FSGSmatrixPeriodic)->push_back(pair<int,int>(i1,i2)) ;
    } ENDFORALL ;
  } ;


  struct lineLayout {
    int eqnstart,eqnend,Lstart,Ustart,OuterStart,OuterEnd ;
  } ;

  struct matrixStructure {
    int access_counter ;
    // equation variable map
    int nmyeqn ;
    vector<int> eql2g ; // Local to global map for equation information
    // line information
    vector<lineLayout> lineData ;
    vector<int> foffsets ;
    // maximum line length
    int mxlinelen ;
    // Global to local map for off diagonal matrix information
    const_Map globalL2l,globalU2l ;
    // connectivity information
    vector<pair<int,int> > outerCLR ; // outer face left/right eqn numbers
    
    //
    // Communication structure
    vector<int> send_processors ;
    vector<int> send_offsets ;
    vector<int> send_entities ;
    vector<int> send_entitiesl ;
    vector<int> recv_processors ;
    vector<int> recv_offsets ;
    vector<int> recv_entities ;
    vector<int> recv_entitiesl ;

    vector<pair<int,int> > periodicCopy ;

    matrixStructure(const matrixStructure &ms) {
      access_counter = ms.access_counter ;
      nmyeqn = ms.nmyeqn ;
      eql2g = ms.eql2g ;
      lineData = ms.lineData ;
      foffsets = ms.foffsets ;
      mxlinelen = ms.mxlinelen ;
      outerCLR = ms.outerCLR ;
      globalL2l.setRep(ms.globalL2l.Rep()) ;
      globalU2l.setRep(ms.globalU2l.Rep()) ;
      send_processors = ms.send_processors ;
      send_offsets = ms.send_offsets ;
      send_entities = ms.send_entities ;
      send_entitiesl = ms.send_entitiesl ;
      recv_processors = ms.recv_processors ;
      recv_offsets = ms.recv_offsets ;
      recv_entities = ms.recv_entities ;
      recv_entitiesl = ms.recv_entitiesl ;
      periodicCopy = ms.periodicCopy ;
    }
    matrixStructure &operator=(const matrixStructure &ms) {
      access_counter = ms.access_counter ;
      nmyeqn = ms.nmyeqn ;
      eql2g = ms.eql2g ;
      lineData = ms.lineData ;
      foffsets = ms.foffsets ;
      mxlinelen = ms.mxlinelen ;
      outerCLR = ms.outerCLR ;
      globalL2l.setRep(ms.globalL2l.Rep()) ;
      globalU2l.setRep(ms.globalU2l.Rep()) ;
      send_processors = ms.send_processors ;
      send_offsets = ms.send_offsets ;
      send_entities = ms.send_entities ;
      send_entitiesl = ms.send_entitiesl ;
      recv_processors = ms.recv_processors ;
      recv_offsets = ms.recv_offsets ;
      recv_entities = ms.recv_entities ;
      recv_entitiesl = ms.recv_entitiesl ;
      periodicCopy = ms.periodicCopy ;
      return *this ;
    }
    matrixStructure() { access_counter = -1 ;}
    ~matrixStructure() {}
  } ;

  $type FSGSmatrixTopology blackbox<matrixStructure> ;


  struct scalarMatrixData {
    vector<real> B ;
    vector<real> D ;
    vector<real> F ;
  } ;

  $type FSGSscalarMatrix(X) blackbox<scalarMatrixData> ;
  $type fluidLinearSolverFSGS Constraint ;
  $rule blackbox(FSGSmatrixInitialize),constraint(fluidLinearSolverFSGS),prelude {
    $FSGSmatrixInitialize = 1 ; 
  } ;

  
  $rule blackbox(FSGSmatrixTopology<-cellcenter,FSGSmatrixPeriodic,
		 lower->cl->cellcenter,upper->cr->cellcenter,
		 (lower,upper)->area, FSGSmatrixInitialize),
    option(disable_threading), prelude {
    struct matrixStructure &matrix = *$FSGSmatrixTopology ;
    if(matrix.access_counter < 0) { 
	if(Loci::MPI_processes > 1) {
	  Loci::fact_db::distribute_infoP df = 
	    Loci::exec_current_fact_db->get_distribute_info() ;
	  Map l2g ;
	  l2g = df->l2g.Rep() ;
	  entitySet dom = $cellcenter.domain() ;
	  entitySet mydom = dom ;
	  mydom &= df->my_entities ;
	  Loci::MapRepP clm = Loci::MapRepP($cl.Rep()) ;
	  Loci::MapRepP crm = Loci::MapRepP($cr.Rep()) ;
	  Loci::MapRepP lowerm = Loci::MapRepP($lower.Rep()) ;
	  Loci::MapRepP upperm = Loci::MapRepP($upper.Rep()) ;

	  entitySet access_dom = (clm->image(lowerm->image(mydom)) +
				  crm->image(upperm->image(mydom)) +
				  mydom) ;
      
	  // Temporary map from global back to local
	  std::map<int,int> g2l ;
	  FORALL(access_dom,ii) {
	    g2l[l2g[ii]] = ii ;
	  } ENDFORALL ;

	  // Entities that we access that we don't own in local numbering
	  Loci::entitySet localcom = access_dom-df->my_entities ;
	  // Entities that we need to recieve in global numbering
	  Loci::entitySet rset = Loci::MapRepP(l2g.Rep())->image(localcom) ;
	  std::vector<entitySet> &ptn = Loci::exec_current_fact_db->get_init_ptn() ;
	  vector<pair<int,vector<int> > > recv_sets ;
	  for(int i=0;i<Loci::MPI_processes;++i) {
	    entitySet rpset = rset & ptn[i] ;
	    if(rpset != EMPTY) {
	      if(i == Loci::MPI_rank) {
		cerr << "inconsistent self communcation found in line gsi code" << endl ;
		Loci::Abort() ;
	      }
	      vector<int> recv_set(rpset.size()) ;
	      int cnt = 0 ;
	      Loci::entitySet::const_iterator ei ;
	      for(ei=rpset.begin();ei!=rpset.end();++ei) {
		recv_set[cnt] = *ei ;
		cnt++ ;
	      }
	      recv_sets.push_back(pair<int,vector<int> >(i,recv_set)) ;
	    }
	  }
	  vector<int> recv_cnts(Loci::MPI_processes,0) ;
	  for(size_t i=0;i<recv_sets.size();++i) {
	    recv_cnts[recv_sets[i].first] = recv_sets[i].second.size() ;
	  }
	  vector<int> send_cnts(Loci::MPI_processes,0) ;
	  MPI_Alltoall(&recv_cnts[0],1,MPI_INT,&send_cnts[0],1,MPI_INT,
		       MPI_COMM_WORLD) ;
      
	  int cc = 0 ;
	  for(int i=0;i<Loci::MPI_processes;++i) {
	    if(send_cnts[i] > 0) 
	      cc++ ;
	  }

	  vector<pair<int,vector<int> > > send_sets(cc) ;
	  vector<MPI_Request> requests(cc) ;
	  
	  cc = 0 ;
	  for(int i=0;i<Loci::MPI_processes;++i) {
	    if(send_cnts[i] > 0) {
	      send_sets[cc] = pair<int,vector<int> >(i,vector<int>(send_cnts[i])) ;
	      MPI_Irecv(&(send_sets[cc].second[0]),send_cnts[i],MPI_INT,i,99,
			MPI_COMM_WORLD,&requests[cc]) ;
	      cc++ ;
	    }
	  }
	  for(size_t i=0;i<recv_sets.size();++i) {
	    int p = recv_sets[i].first ;
	    int sz = recv_sets[i].second.size() ;
	    MPI_Send(&(recv_sets[i].second[0]),sz,MPI_INT,p,99,MPI_COMM_WORLD) ;
	  }
	  vector<MPI_Status> status(requests.size()) ;
	  MPI_Waitall(requests.size(),&requests[0],&status[0]) ;
    
	  // Now convert send and recv lists to local numbering
	  for(size_t i=0;i<recv_sets.size();++i) {
	    int rsz = recv_sets[i].second.size() ;
	    for(int j=0;j<rsz;++j) {
	      std::map<int,int>::const_iterator ii = g2l.find(recv_sets[i].second[j]) ;
	      if(ii == g2l.end()) {
		cerr << "g2l undefined" << endl ;
		Loci::Abort() ;
	      }
	      recv_sets[i].second[j] = ii->second ;
	    }
	  }
	  for(size_t i=0;i<send_sets.size();++i) {
	    int ssz = send_sets[i].second.size() ;
	    for(int j=0;j<ssz;++j) {
	      std::map<int,int>::const_iterator ii = g2l.find(send_sets[i].second[j]) ;
	      if(ii == g2l.end()) {
		cerr << "g2l undefined" << endl ;
		Loci::Abort() ;
	      }
	      send_sets[i].second[j] = ii->second ;
	    }
	  }
	  // Assign communication info
	  matrix.send_processors = vector<int>(send_sets.size()) ;
	  matrix.send_offsets = vector<int>(send_sets.size()+1) ;
	  matrix.send_offsets[0] = 0 ;
	  int sendsize = 0; 
	  for(size_t i=0;i<send_sets.size();++i) {
	    matrix.send_processors[i] = send_sets[i].first ;
	    sendsize += send_sets[i].second.size() ;
	    matrix.send_offsets[i+1] = sendsize ;
	  }
	  matrix.send_entities = vector<int>(sendsize) ;
	  for(size_t i=0;i<send_sets.size();++i) 
	    for(size_t j=0;j<send_sets[i].second.size();++j)
	      matrix.send_entities[matrix.send_offsets[i]+j] 
		= send_sets[i].second[j] ;

	  matrix.recv_processors = vector<int>(recv_sets.size()) ;
	  matrix.recv_offsets = vector<int>(recv_sets.size()+1) ;
	  matrix.recv_offsets[0] = 0 ;
	  int recvsize = 0; 
	  for(size_t i=0;i<recv_sets.size();++i) {
	    matrix.recv_processors[i] = recv_sets[i].first ;
	    recvsize += recv_sets[i].second.size() ;
	    matrix.recv_offsets[i+1] = recvsize ;
	  }
	  matrix.recv_entities = vector<int>(recvsize) ;
	  for(size_t i=0;i<recv_sets.size();++i) 
	    for(size_t j=0;j<recv_sets[i].second.size();++j)
	      matrix.recv_entities[matrix.recv_offsets[i]+j] 
		= recv_sets[i].second[j] ;
	} else {
	  // Assign communication info
	  matrix.send_processors = vector<int>(0) ;
	  matrix.send_offsets = vector<int>(1) ;
	  matrix.send_offsets[0] = 0 ;
	  matrix.send_entities = vector<int>(0) ;

	  matrix.recv_processors = vector<int>(0) ;
	  matrix.recv_offsets = vector<int>(1) ;
	  matrix.recv_offsets[0] = 0 ;
	  matrix.recv_entities = vector<int>(0) ;
	}
    }

    if(matrix.access_counter < 0) {
      matrix.access_counter = 0 ;
      // Build temporary connectivity matrix
      entitySet dom = ($lower.domain() & $upper.domain()) ;
      entitySet mydom = dom ;
	
      if(Loci::MPI_processes > 1)
        mydom &= Loci::exec_current_fact_db->get_distribute_info()->my_entities ;

      Loci::MapRepP clm = Loci::MapRepP($cl.Rep()) ;
      Loci::MapRepP crm = Loci::MapRepP($cr.Rep()) ;
      Loci::MapRepP lowerm = Loci::MapRepP($lower.Rep()) ;
      Loci::MapRepP upperm = Loci::MapRepP($upper.Rep()) ;
      
      entitySet access_dom = (clm->image(lowerm->image(mydom)) +
			      crm->image(upperm->image(mydom)) +
			      mydom) ;
      dom += access_dom ;
      if($FSGSmatrixPeriodic->size() > 0) {
	vector<int> val($FSGSmatrixPeriodic->size()*2) ;
	for(size_t i=0;i<$FSGSmatrixPeriodic->size();++i) {
	  val[i*2] = (*$FSGSmatrixPeriodic)[i].first ;
	  val[i*2+1] = (*$FSGSmatrixPeriodic)[i].second ;
	}
	entitySet pdom = create_entitySet(val.begin(),val.end()) ;
	dom += pdom ;
      }

      vector<int> index(dom.size()) ;
      Map toeqn ;
      toeqn.allocate(dom) ;
      int cnt = 0 ;
      // First number all equations owned by this processor
      int nmyeqn = mydom.size() ;
      FORALL(mydom,ii) {
        index[cnt] = ii ;
        toeqn[ii] = cnt ;
        cnt++ ;
      } ENDFORALL ;
      // Then number equations referenced by this processor
      entitySet remainder = dom-mydom ;
      FORALL(remainder,ii) {
        index[cnt] = ii ;
        toeqn[ii] = cnt ;
        cnt++ ;
      } ENDFORALL ;
      //    cout << "nmyeqn=" << nmyeqn << ",rem = " << remainder.size() << endl ;
      vector<int> offsets(nmyeqn+1) ;
      offsets[0] = 0 ;
      cnt = 1 ;
      int totsz = 0 ;
      FORALL(mydom,ii) {
        const int lsz = $lower[ii].size() ;
        const int usz = $upper[ii].size() ;
        const int msz = lsz+usz ;
        totsz += msz ;
        offsets[cnt] = totsz ;
        cnt++ ;
      } ENDFORALL ;    

      vector<pair<int,int> > couples ;
      vector<int> neighbors(totsz) ;
      cnt = 0 ;
      FORALL(mydom,ii) {
        const int lsz = $lower[ii].size() ;
        const int usz = $upper[ii].size() ;
        for(int i=0;i<lsz;++i) {
          neighbors[offsets[cnt]+i] = toeqn[$cl[$lower[ii][i]]] ;
        }
        for(int i=0;i<usz;++i) {
          neighbors[offsets[cnt]+i+lsz] = toeqn[$cr[$upper[ii][i]]] ;
        }
        cnt++ ;
      } ENDFORALL ;

      vector<pair<int,int> > connections(mydom.size()) ;
      
      for(int i=0;i<nmyeqn;++i) {
        connections[i].first = -1 ;
        connections[i].second = -1 ;
      }
      vector<int> lineNo(dom.size(),-2) ;
      FORALL(mydom,ii) {
        lineNo[toeqn[ii]] = -1 ;
      } ENDFORALL ;
      int lineno = 0 ;

      for(int i=0;i<nmyeqn;++i) {
	lineNo[i] = i ;
	lineno++ ;
      }
      // Create list of lines
      vector<pair<int,int> > lineinfo(lineno) ;
      for(int i=0;i<nmyeqn;++i) {
        if(connections[i].first == -1)
          lineinfo[lineNo[i]].first = i ;
        if(connections[i].second == -1)
          lineinfo[lineNo[i]].second = i ;
      }

      // Order lines based on breadth first search.
      vector<int> line_order ;
      vector<int> line_visit(lineno,0) ;
      set<int> linedata ;
      int sp = 0 ;
      while(int(line_order.size()) != lineno) {
        if(linedata.empty()) {
          while(sp < lineno && line_visit[sp] != 0)
            sp++;
          if(sp == lineno) {
            // Finished with line list so exit loop
            break ;
          }
          linedata.insert(sp) ;
          line_visit[sp] = 1 ;
        }
        set<int> linedata_next ;
        set<int>::const_iterator ii ;
        for(ii=linedata.begin();ii!=linedata.end();++ii) {
          int l = *ii ;
          for(int j=lineinfo[l].first;j>=0;j=connections[j].second) {
            for(int k=offsets[j];k<offsets[j+1];++k) {
	      if(neighbors[k] < nmyeqn) {
		int nl =lineNo[neighbors[k]] ;
		if(line_visit[nl]==0) {
		  line_visit[nl] = 1 ;
		  linedata_next.insert(nl) ;
		}
              }
            }
          }
          if(lineinfo[l].first >=0)
            line_order.push_back(l) ;
        }
        linedata = linedata_next ;
      }
    
      // Now lines are sorted for SGS sweeps in line_order, now reorder eqns and
      // collect data structure for high performance implementation.
    
      vector<int> eqnorder(dom.size()) ;
      vector<int> eqnvisit(dom.size(),0) ;
      vector<int> line_offsets(line_order.size()+1) ;

      line_offsets[0] = 0 ;
      cnt = 0 ;
      for(size_t i=0;i<line_order.size();++i) {
        int ln = line_order[i] ;
        for(int j=lineinfo[ln].first;j>=0;j=connections[j].second) {
          if(eqnvisit[j] == 0) {
            eqnorder[cnt] = j ;
            cnt++ ;
            eqnvisit[j] = 1 ;
          } else {
            cerr << "equation visited by more than one line!" << endl ;
          }
        }
        line_offsets[i+1] = cnt ;
      }
      if(cnt != (int)dom.size()) { // Number the remaining equations
        // Sort in order of first visited while scanning lines
        for(int i = nmyeqn-1;i>=0;--i) {
          for(int k=offsets[eqnorder[i]];k<offsets[eqnorder[i]+1];++k)
            if(neighbors[k] >= nmyeqn)
              eqnorder[neighbors[k]] = eqnorder[i] ;
        }
        vector<pair<int,int> > vpairs(dom.size()-nmyeqn) ;
        for(int i=nmyeqn;i<(int)dom.size();++i) {
          vpairs[i-nmyeqn].first = eqnorder[i] ;
          vpairs[i-nmyeqn].second = i ;
        }
        sort(vpairs.begin(),vpairs.end()) ;
        for(int i=nmyeqn;i<(int)dom.size();++i) {
          eqnorder[i] = vpairs[i-nmyeqn].second ;
        }
      }
      
      // build equation local 2 entity number map
      vector<int> eql2l(dom.size()) ; // map from old local number 2 new one
      { vector<int> eql2g(dom.size()) ;
	std::map<int,int> g2eql ;
        for(int i=0;i<(int)dom.size();++i) {
          eql2g[i] = index[eqnorder[i]] ;
	  g2eql[eql2g[i]] = i ;
          eql2l[eqnorder[i]] = i ;
        }
        matrix.eql2g.swap(eql2g) ;
	vector<int> recv_entitiesl(matrix.recv_entities.size()) ;
	for(size_t i=0;i<recv_entitiesl.size();++i)
	  recv_entitiesl[i] = g2eql[matrix.recv_entities[i]] ;
	matrix.recv_entitiesl.swap(recv_entitiesl) ;
	vector<int> send_entitiesl(matrix.send_entities.size()) ;
	for(size_t i=0;i<send_entitiesl.size();++i)
	  send_entitiesl[i] = g2eql[matrix.send_entities[i]] ;
	matrix.send_entitiesl.swap(send_entitiesl) ;
	matrix.nmyeqn = nmyeqn ;

	// Now handle periodic
	int psz = (*$FSGSmatrixPeriodic).size() ;
	vector<pair<int,int> > periodicCopy(psz) ;
	for(int i=0;i<psz;++i) {
	  periodicCopy[i].first = g2eql[(*$FSGSmatrixPeriodic)[i].first] ;
	  periodicCopy[i].second = g2eql[(*$FSGSmatrixPeriodic)[i].second] ;
	}
	matrix.periodicCopy.swap(periodicCopy) ;
      }
      
      // build line data structures
      int nlines = line_order.size() ;
      vector<lineLayout> lineData(nlines) ;

      matrix.mxlinelen = 0 ;
      cnt = 0 ;
      for(int i=0;i<nlines;++i) {
        int lsz = line_offsets[i+1]-line_offsets[i] ;
        matrix.mxlinelen = max(matrix.mxlinelen,lsz) ;
        lineData[i].eqnstart = line_offsets[i] ;
        lineData[i].eqnend = line_offsets[i+1] ;
        lineData[i].Lstart = cnt ;
        cnt += lsz-1 ;
        lineData[i].Ustart = cnt ;
        cnt += lsz-1 ;
        lineData[i].OuterStart = cnt ;
        for(int j=line_offsets[i];j<line_offsets[i+1];++j)
          cnt+= offsets[eqnorder[j]+1]-offsets[eqnorder[j]]-2 ;
        cnt += 2 ;
        lineData[i].OuterEnd = cnt ;
      }
      entitySet Ldom = Loci::MapRepP($lower.Rep())->image(mydom) ;
      entitySet Udom = Loci::MapRepP($upper.Rep())->image(mydom) ;
      Map globalL2l,globalU2l ;
      globalL2l.allocate(Ldom) ;
      globalU2l.allocate(Udom) ;
      vector<pair<int,int> > outerCLR(cnt) ;
      for(int i=0;i<nlines;++i) {
        int ln = line_order[i] ;
        // scan line and find line L and U
        int c1=lineData[i].Lstart ;
        int c2=lineData[i].Ustart ;
        int c3=lineData[i].OuterStart ;
        for(int j=lineinfo[ln].first;j>=0;j=connections[j].second) {
          // scan neighbors of this equation
          const int lsz = $lower[index[j]].size() ;
          for(int k=offsets[j];k<offsets[j+1];++k) {

            const int n =neighbors[k] ;
            int localid = -1 ;
            // find local id of this connection
            if(n == connections[j].first) {
              // L tridiagonal term
              localid = c1++ ;
            } else if(n == connections[j].second) {
              localid = c2++ ;
              // U tridiagonal term
            } else {
              // outer term
              localid = c3++ ;
            }
            // store connectivity
            outerCLR[localid].first = eql2l[j] ;
            outerCLR[localid].second = eql2l[n] ;
            int fid = (k-offsets[j]) ;
            // fill in matrix injection maps
            if(fid < lsz) {
              globalL2l[$lower[index[j]][fid]] = localid ;
            } else {
              globalU2l[$upper[index[j]][fid-lsz]] = localid ;
            }
          }
        }
      }

      matrix.globalL2l.setRep(globalL2l.Rep()) ;
      matrix.globalU2l.setRep(globalU2l.Rep()) ;
      matrix.outerCLR.swap(outerCLR) ;

      matrix.lineData = lineData ;
      vector<int> foffsets(lineData.size()+1) ;
      foffsets[0] = 0 ;
      for(size_t i=0;i<lineData.size();++i)
	foffsets[i+1] = lineData[i].OuterEnd ;
      matrix.foffsets.swap(foffsets) ;
    }
    
    matrix.access_counter++ ;

  } ;


  $rule blackbox(FSGSscalarMatrix(X)<-FSGSmatrixTopology,
		 X_B,X_D,upper->X_U,lower->X_L), prelude {
    const struct matrixStructure & restrict matrix = *$FSGSmatrixTopology ;
    vector<real> B(matrix.eql2g.size()); 
    vector<real> D(matrix.eql2g.size()); 
    vector<real> F(matrix.outerCLR.size()); 
    
    // Copy matrix into data structure
    for(int i=0;i<matrix.nmyeqn;++i) {
      D[i] = $X_D[matrix.eql2g[i]] ;
      B[i] = $X_B[matrix.eql2g[i]] ;
    }
    entitySet ldom  = matrix.globalL2l.domain() ;
    FORALL(ldom,ii) {
      F[matrix.globalL2l[ii]] = $X_L[ii] ;
    } ENDFORALL ;
    entitySet udom  = matrix.globalU2l.domain() ;
    FORALL(udom,ii) {
      F[matrix.globalU2l[ii]] = $X_U[ii] ;
    } ENDFORALL ;

    // Preprocess lines (recompute diagonal term)
    for(size_t l=0;l<matrix.lineData.size();++l) { // loop over lines
      real *L = &F[matrix.lineData[l].Lstart] ;
      real *U = &F[matrix.lineData[l].Ustart] ;
      real *restrict Dp = &D[matrix.lineData[l].eqnstart] ;
      int lsz = matrix.lineData[l].eqnend-matrix.lineData[l].eqnstart ;
      
      //      D[0] = 1./(D[0]<0.0?min<real>(D[0],-1e-30):max<real>(D[0],1e-30)) ;
      Dp[0] = 1./Dp[0] ;
      for(int i=1;i<lsz;++i) {
        real Dt = (Dp[i]-L[i-1]*Dp[i-1]*U[i-1]) ;
        Dp[i] = 1./(Dt<0.0?min<real>(Dt,-1e-30):max<real>(Dt,1e-30)) ;
      }
    }
    $FSGSscalarMatrix(X)->B.swap(B) ; 
    $FSGSscalarMatrix(X)->D.swap(D) ; 
    $FSGSscalarMatrix(X)->F.swap(F) ; 
    
  } ;

  $type FSGSScalarSolve(X)           store<real> ;


  $rule pointwise(FSGSScalarSolve(X)<-FSGSMaxIter(X),FSGSMatrixName(X),
                  FSGSDiagnosticLevel(X),
		  FSGSscalarMatrix(X),FSGSmatrixTopology),
                 option(disable_threading),
                 prelude {
    const struct matrixStructure & restrict matrix = *$FSGSmatrixTopology ;
    // Copy in x to our cache optimal ordering
    bool printResidual = *$FSGSDiagnosticLevel(X) > 0 ;
    
    vector<real> x1(matrix.eql2g.size(),0.0);
    vector<real> x2 ;
    if(printResidual) {
      vector<real> tmp(matrix.eql2g.size(),0.0);
      x2.swap(tmp) ;
    }
    real * X = &x1[0] ;
    vector<real> rhs(matrix.mxlinelen) ;
    vector<real> send_data(matrix.send_entitiesl.size()) ;
    vector<real> recv_data(matrix.recv_entitiesl.size()) ;
    vector<MPI_Request> requests(matrix.recv_processors.size()) ;
    vector<MPI_Status> status(matrix.recv_processors.size()) ;
    
    int num_iter = *$FSGSMaxIter(X) ;
    // do num_iter steps
    double zero_resid = 0 ;
    for(int iter = 0;iter < num_iter;++iter) {
      if(iter != 0) { // On first step, the values are just zero, no need to
	// send anything
        
	int psz = matrix.periodicCopy.size() ;
	for(int i=0;i<psz;++i)
	  X[matrix.periodicCopy[i].first] = X[matrix.periodicCopy[i].second] ;

	// copy send data 
	for(size_t i=0;i<send_data.size();++i)
	  send_data[i] = X[matrix.send_entitiesl[i]] ;
	
	for(size_t i=0;i<matrix.recv_processors.size();++i) {
	  int rs = matrix.recv_offsets[i] ;
	  int re = matrix.recv_offsets[i+1] ;
	  int rsz = re-rs ;
	  int p = matrix.recv_processors[i] ;
	  MPI_Irecv(&recv_data[rs],rsz,FSGS_TYPE,p,99,
		    MPI_COMM_WORLD,&requests[i]) ;
	}
	for(size_t i=0;i<matrix.send_processors.size();++i) {
	  int ss = matrix.send_offsets[i] ;
	  int se = matrix.send_offsets[i+1] ;
	  int ssz = se-ss ;
	  int p = matrix.send_processors[i] ;
	  MPI_Send(&send_data[ss],ssz,FSGS_TYPE,p,99,MPI_COMM_WORLD) ;
	}
	MPI_Waitall(requests.size(),&requests[0],&status[0]) ;
	// copy recieved data 
	for(size_t i=0;i<recv_data.size();++i)
	  X[matrix.recv_entitiesl[i]] = recv_data[i] ;
	for(int i=0;i<psz;++i)
	  X[matrix.periodicCopy[i].first] = X[matrix.periodicCopy[i].second] ;
      }
      
      // Forward sweep
      for(size_t l=0;l<matrix.lineData.size();++l) { // loop over lines
	const real *L = &$FSGSscalarMatrix(X)->F[matrix.lineData[l].Lstart] ;
	const real *U = &$FSGSscalarMatrix(X)->F[matrix.lineData[l].Ustart] ;
	const real *D = &$FSGSscalarMatrix(X)->D[matrix.lineData[l].eqnstart] ;
	const real *B = &$FSGSscalarMatrix(X)->B[matrix.lineData[l].eqnstart] ;
	const real *F = &$FSGSscalarMatrix(X)->F[0] ;

	const int lsz = matrix.lineData[l].eqnend-matrix.lineData[l].eqnstart ;

	const int eqb = matrix.lineData[l].eqnstart ;

	// First compute rhs ;
	for(int i=0;i<lsz;++i)
	  rhs[i] = B[i] ;

	const int   os = matrix.lineData[l].OuterStart ;
	const int   oe = matrix.lineData[l].OuterEnd ;
	for(int i=os;i<oe;++i) {
	  rhs[matrix.outerCLR[i].first-eqb] -= X[matrix.outerCLR[i].second]*F[i] ;
	}
      

	real *restrict x = &X[eqb] ;
	// now solve line
	// forward solve 
	x[0] = rhs[0] ;
	for(int i=1;i<lsz;++i) {
	  x[i] = rhs[i] - L[i-1]*D[i-1]*x[i-1] ;
	}
	// backward solve
	x[lsz-1] = D[lsz-1]*x[lsz-1] ;
	for(int i=lsz-2;i>=0;--i) {
	  x[i] = D[i]*(x[i] - x[i+1]*U[i]) ;
	}
      }
      X = &x1[0] ;

      // Backward sweep
      for(int l=matrix.lineData.size()-1;l>=0;--l) { // loop over lines
	const real *L = &$FSGSscalarMatrix(X)->F[matrix.lineData[l].Lstart] ;
	const real *U = &$FSGSscalarMatrix(X)->F[matrix.lineData[l].Ustart] ;
	const real *D = &$FSGSscalarMatrix(X)->D[matrix.lineData[l].eqnstart] ;
	const real *B = &$FSGSscalarMatrix(X)->B[matrix.lineData[l].eqnstart] ;
	const real *F = &$FSGSscalarMatrix(X)->F[0] ;

	const int lsz = matrix.lineData[l].eqnend-matrix.lineData[l].eqnstart ;

	const int eqb = matrix.lineData[l].eqnstart ;

	// First compute rhs ;
	for(int i=0;i<lsz;++i)
	  rhs[i] = B[i] ;

	const int   os = matrix.lineData[l].OuterStart ;
	const int   oe = matrix.lineData[l].OuterEnd ;
	for(int i=os;i<oe;++i) {
	  rhs[matrix.outerCLR[i].first-eqb] -= X[matrix.outerCLR[i].second]*F[i] ;
	}

	real *restrict x = &X[eqb] ;
	// now solve line
	// forward solve 
	x[0] = rhs[0] ;
	for(int i=1;i<lsz;++i) {
	  x[i] = rhs[i] - L[i-1]*D[i-1]*rhs[i-1] ;
	}
	// backward solve
	x[lsz-1] = D[lsz-1]*x[lsz-1] ;
	for(int i=lsz-2;i>=0;--i) {
	  x[i] = D[i]*(x[i] - x[i+1]*U[i]) ;
	}
      }

      if(printResidual) {
        double residl = 0 ;
        for(int i=0;i<matrix.nmyeqn;++i) {
          double r = realToDouble((X[i]-x2[i])) ;
          x2[i] = X[i] ;
          residl += r*r ;
        }
        double resid = 0 ;
        MPI_Allreduce(&residl,&resid,1,MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD) ;
        resid = sqrt(resid) ;
        if(0 == iter)
          zero_resid = max(resid,1e-16) ;

        double rel_resid = resid/zero_resid ;
        if(Loci::MPI_rank == 0) {
          cout << "FSGS Matrix " << *$FSGSMatrixName(X) 
               << ", iter=" << iter+1 
               << ", resid=" << resid << ", rel_resid=" << rel_resid << endl ;
        }
      }

    }    
    
    // copy data out
    for(int i=0;i<matrix.nmyeqn;++i) {
      $FSGSScalarSolve(X)[matrix.eql2g[i]] = x1[i] ; 
    }

  } ;
    

#ifdef DOUBLE_FJMAT
  typedef real real_fj ;
#else
  typedef realF real_fj ;
#endif

// Blocked version
  $type Y_B storeVec<real_fj> ;
  $type Y_D storeMat<real_fj> ;
  $type Y_L storeMat<real_fj> ;
  $type Y_U storeMat<real_fj> ;
  $type FSGSBlockedSSolve(Y) storeVec<real> ;
  $type FSGSBlockedSSolve_next(Y) storeVec<real> ;
  $type FSGSBlockedSSolve_forward(Y) storeVec<real> ;
  $type FSGSBlockedSSolve_backward(Y) storeVec<real> ;
  $type FSGSgseidel_finished(Y) param<bool> ;

  using flowPsi::tmp_array ;



  class matrixHelpers: public Loci::CPTR_type {
  public:
    virtual void factorDiagonal(real_fj *D, pivot_type *pivot,
				int neq, int vs) const = 0 ;

    virtual void sweep(real *X, const real_fj *B, 
		       const real_fj *D, const pivot_type *pivot,
		       const pair<int,int> *CLR, const real_fj *F,
		       const int *foffsets, int neq, bool forward, int vs) const = 0 ;
		       
  } ;

  class matrixHelpersGeneric: public matrixHelpers {
  public:
    virtual void factorDiagonal(real_fj *D, pivot_type *pivot,
				int neq, int vs) const ;
    virtual void sweep(real *X, const real_fj *B, 
		       const real_fj *D, const pivot_type *pivot,
		       const pair<int,int> *CLR, const real_fj *F,
		       const int *foffsets, int neq, bool forward, int vs) const ;
  } ;

  void matrixHelpersGeneric::
  factorDiagonal(real_fj *restrict D, pivot_type *restrict pivot,
		 int neq, int vs) const {
    int vs2 = vs*vs ;
    for(int i=0;i<neq;++i) {
      Mat<real_fj> Di(D,vs) ;
      Di.decompose_lu_pivot(pivot) ;
      D += vs2 ;
      pivot += vs ;
    }
  }

  void matrixHelpersGeneric::
  sweep(real *restrict X, const real_fj *restrict B, 
	const real_fj *restrict D, const pivot_type *restrict pivot,
	const pair<int,int> *restrict CLR, const real_fj *restrict F,
	const int *restrict foffsets, int neq, bool forward, int vs) const {
    
    int vs2 = vs*vs ;
    int dir = forward?1:-1 ;
    int vstep = dir*vs ;
    int mstep = dir*vs2 ;
    int e = forward?0:neq-1 ;
    int voffset = e*vs ;
    int moffset = e*vs2 ;
    vector<real> t(vs) ;
    for(int eq=0;eq<neq;++eq) {
      for(int i=0;i<vs;++i)
	t[i] = -B[voffset+i] ;
      const real_fj *restrict Ft = &F[foffsets[e]*vs2] ;
      for(int i=foffsets[e];i<foffsets[e+1];++i)  {
	const_Mat<real_fj> Fi(Ft,vs) ;
	Fi.dotprod_accum(&X[CLR[i].second*vs],&t[0]) ;
	Ft += vs2 ;
      }
      for(int i=0;i<vs;++i)
	t[i] = -t[i] ;
      const_Mat<real_fj> De(&D[moffset],vs) ;
      De.solve_lu_pivot(&t[0],&X[voffset],&pivot[voffset]) ;
      //De.solve_lu(&X[voffset],&v[0]) ;
      e += dir ;
      voffset += vstep ;
      moffset += mstep ;
    }
  }

  template <int N>
  class matrixHelpersNoPivotN: public matrixHelpers {
  public:
    virtual void factorDiagonal(real_fj *D, pivot_type *pivot,
				int neq, int vsin) const {
      const int vs = N ;
      const int vs2 = N*N ;
      for(int i=0;i<neq;++i) {
	Mat<real_fj> Di(D,vs) ;
	Di.decompose_lu() ;
	D += vs2 ;
	pivot += vs ;
      }
    }
    virtual void sweep(real *X, const real_fj *B, 
		       const real_fj *D, const pivot_type *pivot,
		       const pair<int,int> *CLR, const real_fj *F,
		       const int *foffsets, int neq, bool forward, int vsin) const {
      const int vs = N ;
      const int vs2 = N*N ;
      int dir = forward?1:-1 ;
      int vstep = dir*vs ;
      int mstep = dir*vs2 ;
      int e = forward?0:neq-1 ;
      int voffset = e*vs ;
      int moffset = e*vs2 ;
      vector<real> t(vs) ;
#ifdef HAVE_IVDEP
#pragma vector unaligned
#endif
      for(int eq=0;eq<neq;++eq) {
#ifdef HAVE_IVDEP
#pragma vector unaligned
#pragma ivdep
#endif
	for(int i=0;i<vs;++i)
	  t[i] = -B[voffset+i] ;
	const real_fj *restrict Ft = &F[foffsets[e]*vs2] ;
#ifdef HAVE_IVDEP
#pragma vector unaligned
#endif
	for(int i=foffsets[e];i<foffsets[e+1];++i)  {
	  //	const_Mat<real_fj> Fi(Ft,vs) ;
	  dotprod_accum_N<N,real_fj,real,real>(Ft,&X[CLR[i].second*vs],&t[0]) ;
	  Ft += vs2 ;
	}
#ifdef HAVE_IVDEP
#pragma vector unaligned
#pragma ivdep
#endif
	for(int i=0;i<vs;++i)
	  t[i] = -t[i] ;
	//      const_Mat<real_fj> De(&D[moffset],vs) ;
	solve_lu_N<N,real_fj,real,real> (&D[moffset],&t[0],&X[voffset]) ;
	//      De.solve_lu(&t[0],&X[voffset]) ;
	//De.solve_lu(&X[voffset],&v[0]) ;
	e += dir ;
	voffset += vstep ;
	moffset += mstep ;
      }
    }
  } ;

  // specialized for the 9x9 matrix size
  template <>
  class matrixHelpersNoPivotN<9>: public matrixHelpers {
  public:
    virtual void factorDiagonal(real_fj *D, pivot_type *pivot,
				int neq, int vsin) const {
      const int vs = 9 ;
      const int vs2 = 81 ;
      for(int i=0;i<neq;++i) {
	Mat<real_fj> Di(D,vs) ;
	Di.decompose_lu() ;
	D += vs2 ;
	pivot += vs ;
      }
    }
    virtual void sweep(real *X, const real_fj *B, 
		       const real_fj *D, const pivot_type *pivot,
		       const pair<int,int> *CLR, const real_fj *F,
		       const int *foffsets, int neq, bool forward, int vsin) const {
      const int vs = 9 ;
      const int vs2 = 81 ;
      int dir = forward?1:-1 ;
      int vstep = dir*vs ;
      int mstep = dir*vs2 ;
      int e = forward?0:neq-1 ;
      int voffset = e*vs ;
      int moffset = e*vs2 ;
      vector<real> t(vs) ;
#ifdef HAVE_IVDEP
#pragma vector unaligned
#endif
      for(int eq=0;eq<neq;++eq) {
#ifdef HAVE_IVDEP
#pragma vector unaligned
#pragma ivdep
#endif
	for(int i=0;i<vs;++i)
	  t[i] = -B[voffset+i] ;
	const real_fj *restrict Ft = &F[foffsets[e]*vs2] ;
#ifdef HAVE_IVDEP
#pragma vector unaligned
#endif
	for(int i=foffsets[e];i<foffsets[e+1];++i)  {
	  //	const_Mat<real_fj> Fi(Ft,vs) ;
	  dotprod_accum_N<9,real_fj,real,real>(Ft,&X[CLR[i].second*vs],&t[0]) ;
	  Ft += vs2 ;
	}
#ifdef HAVE_IVDEP
#pragma vector unaligned
#pragma ivdep
#endif
	for(int i=0;i<vs;++i)
	  t[i] = -t[i] ;
	solve_lu_N<9,real_fj,real,real> (&D[moffset],&t[0],&X[voffset]) ;
	e += dir ;
	voffset += vstep ;
	moffset += mstep ;
      }
    }
  } ;

  class matrixHelpersNoPivot: public matrixHelpers {
  public:
    virtual void factorDiagonal(real_fj *D, pivot_type *pivot,
				int neq, int vsin) const ;
    virtual void sweep(real *X, const real_fj *B, 
		       const real_fj *D, const pivot_type *pivot,
		       const pair<int,int> *CLR, const real_fj *F,
		       const int *foffsets, int neq, bool forward, int vsin) const ;
  } ;

    void matrixHelpersNoPivot::
  factorDiagonal(real_fj *restrict D, pivot_type *restrict pivot,
		 int neq, int vs) const {
    int vs2 = vs*vs ;
    for(int i=0;i<neq;++i) {
      Mat<real_fj> Di(D,vs) ;
      Di.decompose_lu() ;
      D += vs2 ;
      pivot += vs ;
    }
  }

  void matrixHelpersNoPivot::
  sweep(real *restrict X, const real_fj *restrict B, 
	const real_fj *restrict D, const pivot_type *restrict pivot,
	const pair<int,int> *restrict CLR, const real_fj *restrict F,
	const int *restrict foffsets, int neq, bool forward, int vs) const {
    
    int vs2 = vs*vs ;
    int dir = forward?1:-1 ;
    int vstep = dir*vs ;
    int mstep = dir*vs2 ;
    int e = forward?0:neq-1 ;
    int voffset = e*vs ;
    int moffset = e*vs2 ;
    vector<real> t(vs) ;
    for(int eq=0;eq<neq;++eq) {
      for(int i=0;i<vs;++i)
	t[i] = -B[voffset+i] ;
      const real_fj *restrict Ft = &F[foffsets[e]*vs2] ;
      for(int i=foffsets[e];i<foffsets[e+1];++i)  {
	const_Mat<real_fj> Fi(Ft,vs) ;
	Fi.dotprod_accum(&X[CLR[i].second*vs],&t[0]) ;
	Ft += vs2 ;
      }
      for(int i=0;i<vs;++i)
	t[i] = -t[i] ;
      const_Mat<real_fj> De(&D[moffset],vs) ;
      De.solve_lu(&t[0],&X[voffset]) ;
      //De.solve_lu(&X[voffset],&v[0]) ;
      e += dir ;
      voffset += vstep ;
      moffset += mstep ;
    }
  }


  struct blockedMatrixData {
    Loci::CPTR<matrixHelpers> matrixHelp ;
    int vs,vs2  ;
    vector<real_fj> B ;
    vector<real_fj> D ;
    vector<pivot_type> pivot ;
    //    vector<real_fj> Dreal ;
    vector<real_fj> F ;
  } ;

  $type FSGSblockedMatrix(Y) blackbox<blockedMatrixData> ;

  $type FSGSUsePivots param<string> ;
  $rule default(FSGSUsePivots) { $FSGSUsePivots = "no" ; }
  $type FSGSPivotSelector param<bool> ;
  $rule singleton(FSGSPivotSelector<-FSGSUsePivots) {
    $FSGSPivotSelector = false ;
    if($FSGSUsePivots == "yes" || $FSGSUsePivots == "on" || $FSGSUsePivots == "true") {
      $FSGSPivotSelector = true ;
    } else if($FSGSUsePivots == "no" || $FSGSUsePivots == "off" || $FSGSUsePivots == "false") {
      $FSGSPivotSelector = false ;
    } else {
      cerr << "unable to interpret setting for 'FSGSUsePivots' in vars file"
	   << endl ;
    }
  }
  $rule blackbox(FSGSblockedMatrix(Y)<-FSGSmatrixTopology,FSGSPivotSelector,
		 Y_B,Y_D,upper->Y_U,lower->Y_L), prelude {
    const struct matrixStructure & restrict matrix = *$FSGSmatrixTopology ;
    int vs = $Y_B.vecSize() ;
    int vs2 = vs*vs ;
    $FSGSblockedMatrix(Y)->vs = vs ;
    $FSGSblockedMatrix(Y)->vs2 = vs2 ;
    if(vs < 40 && !*$FSGSPivotSelector) {
      switch(vs) {
      case 5:
	$FSGSblockedMatrix(Y)->matrixHelp = new matrixHelpersNoPivotN<5> ;
	break ;
      case 6:
	$FSGSblockedMatrix(Y)->matrixHelp = new matrixHelpersNoPivotN<6> ;
	break ;
      case 7:
	$FSGSblockedMatrix(Y)->matrixHelp = new matrixHelpersNoPivotN<7> ;
	break ;
      case 8:
	$FSGSblockedMatrix(Y)->matrixHelp = new matrixHelpersNoPivotN<8> ;
	break ;
      case 9:
	$FSGSblockedMatrix(Y)->matrixHelp = new matrixHelpersNoPivotN<9> ;
	break ;
      case 10:
	$FSGSblockedMatrix(Y)->matrixHelp = new matrixHelpersNoPivotN<10> ;
	break ;
      case 11:
	$FSGSblockedMatrix(Y)->matrixHelp = new matrixHelpersNoPivotN<11> ;
	break ;
      case 12:
	$FSGSblockedMatrix(Y)->matrixHelp = new matrixHelpersNoPivotN<12> ;
	break ;
      case 13:
	$FSGSblockedMatrix(Y)->matrixHelp = new matrixHelpersNoPivotN<13> ;
	break ;
      case 14:
	$FSGSblockedMatrix(Y)->matrixHelp = new matrixHelpersNoPivotN<14> ;
	break ;
      case 15:
	$FSGSblockedMatrix(Y)->matrixHelp = new matrixHelpersNoPivotN<15> ;
	break ;
      case 16:
	$FSGSblockedMatrix(Y)->matrixHelp = new matrixHelpersNoPivotN<16> ;
	break ;
      default:
	$FSGSblockedMatrix(Y)->matrixHelp = new matrixHelpersNoPivot ;
	break ;
      }
    } else 
      $FSGSblockedMatrix(Y)->matrixHelp = new matrixHelpersGeneric ;

    vector<real_fj> B(matrix.eql2g.size()*vs); 
    vector<real_fj> D(matrix.eql2g.size()*vs2); 
    //    vector<real_fj> Dreal(matrix.eql2g.size()*vs2); 
    vector<pivot_type> pivot(matrix.eql2g.size()*vs) ; 
    vector<real_fj> F(matrix.outerCLR.size()*vs2); 
    
    // Copy matrix into data structure

    for(int i=0;i<matrix.nmyeqn;++i) {
      int eqn = matrix.eql2g[i] ;
      const real_fj *restrict Dp = &($Y_D[eqn][0][0]) ;
      const real_fj *restrict Bp = &($Y_B[eqn][0]) ;
      for(int j=0;j<vs2;++j) 
	D[i*vs2+j] = Dp[j] ;
      //      for(int j=0;j<vs2;++j) 
      //	Dreal[i*vs2+j] = Dp[j] ;
      for(int j=0;j<vs;++j) 
	B[i*vs+j] = Bp[j] ;
    }
    entitySet ldom  = matrix.globalL2l.domain() ;
    FORALL(ldom,ii) {
      const real_fj *restrict Lp = &($Y_L[ii][0][0]) ;
      int Findex = matrix.globalL2l[ii]*vs2 ;
      for(int j=0;j<vs2;++j) 
	F[Findex+j] = Lp[j] ;
    } ENDFORALL ;
    entitySet udom  = matrix.globalU2l.domain() ;
    FORALL(udom,ii) {
      const real_fj *restrict Up = &($Y_U[ii][0][0]) ;
      int Findex = matrix.globalU2l[ii]*vs2 ;
      for(int j=0;j<vs2;++j) 
	F[Findex+j] = Up[j] ;
    } ENDFORALL ;


    int nlines = matrix.lineData.size() ;
    $FSGSblockedMatrix(Y)->matrixHelp
      ->factorDiagonal(&D[0],&pivot[0],nlines,vs) ;

    $FSGSblockedMatrix(Y)->B.swap(B) ; 
    $FSGSblockedMatrix(Y)->D.swap(D) ; 
    $FSGSblockedMatrix(Y)->pivot.swap(pivot) ;
    $FSGSblockedMatrix(Y)->F.swap(F) ; 
    //    $FSGSblockedMatrix(Y)->Dreal.swap(Dreal) ; 
  } ;

  $rule pointwise(FSGSBlockedSSolve(Y)<- FSGSMaxIter(Y),FSGSMatrixName(Y),
                  FSGSDiagnosticLevel(Y),
		  FSGSblockedMatrix(Y),FSGSmatrixTopology),
    option(disable_threading),
    prelude {
    bool printResidual = *$FSGSDiagnosticLevel(Y) > 0 ;
    
    const struct matrixStructure & restrict matrix = *$FSGSmatrixTopology ;
    int vs = $FSGSblockedMatrix(Y)->vs ;
    $FSGSBlockedSSolve(Y).setVecSize(vs) ;
    vector<real> x1(matrix.eql2g.size()*vs,0.0) ;
    real *X = &x1[0] ;
    vector<real> x2 ;
    if(printResidual) {
      vector<real> tmp(matrix.eql2g.size()*vs,0.0);
      x2.swap(tmp) ;
    }

    const real_fj *B = &($FSGSblockedMatrix(Y)->B[0]) ;
    const real_fj *F = &($FSGSblockedMatrix(Y)->F[0]) ;
    const pair<int,int> *CLR = &(matrix.outerCLR[0]) ;
    const real_fj *D = &($FSGSblockedMatrix(Y)->D[0]) ;
    const pivot_type *pivot = &($FSGSblockedMatrix(Y)->pivot[0]) ;
    int neq = matrix.lineData.size() ;

    vector<real> send_data(matrix.send_entitiesl.size()*vs) ;
    vector<real> recv_data(matrix.recv_entitiesl.size()*vs) ;
    vector<MPI_Request> requests(matrix.recv_processors.size()) ;
    vector<MPI_Status> status(matrix.recv_processors.size()) ;
    int num_iter = *$FSGSMaxIter(Y) ;
    double zero_resid = 0 ;
    for(int iter = 0;iter<num_iter;++iter) {
      // copy send data 
      int psz = matrix.periodicCopy.size() ;
      for(int i=0;i<psz;++i) {
	for(int j=0;j<vs;++j) {
	  X[matrix.periodicCopy[i].first*vs+j] = X[matrix.periodicCopy[i].second*vs+j] ;
	}
      }
      for(size_t i=0;i<matrix.send_entitiesl.size();++i) {
	int loc = matrix.send_entitiesl[i]*vs ;
	int ii = i*vs ;
	for(int j=0;j<vs;++j)
	  send_data[ii+j] = X[loc+j] ;
      }
      for(size_t i=0;i<matrix.recv_processors.size();++i) {
	int rs = matrix.recv_offsets[i]*vs ;
	int re = matrix.recv_offsets[i+1]*vs ;
	int rsz = re-rs ;
	int p = matrix.recv_processors[i] ;
	MPI_Irecv(&recv_data[rs],rsz,FSGS_TYPE,p,99,
		  MPI_COMM_WORLD,&requests[i]) ;
      }

      for(size_t i=0;i<matrix.send_processors.size();++i) {
	int ss = matrix.send_offsets[i]*vs ;
	int se = matrix.send_offsets[i+1]*vs ;
	int ssz = se-ss ;
	int p = matrix.send_processors[i] ;
	MPI_Send(&send_data[ss],ssz,FSGS_TYPE,p,99,MPI_COMM_WORLD) ;
      }
      MPI_Waitall(requests.size(),&requests[0],&status[0]) ;
      // copy recieved data 
      for(size_t i=0;i<matrix.recv_entitiesl.size();++i) {
	int loc = matrix.recv_entitiesl[i]*vs ;
	int ii = i*vs ;
	for(int j=0;j<vs;++j)
	  X[loc+j] = recv_data[ii+j] ;
      }
      for(int i=0;i<psz;++i) {
	for(int j=0;j<vs;++j) {
	  X[matrix.periodicCopy[i].first*vs+j] = X[matrix.periodicCopy[i].second*vs+j] ;
	}
      }

      // Forward sweep
      $FSGSblockedMatrix(Y)->matrixHelp->
	sweep(X,B,D,pivot,CLR,F,&matrix.foffsets[0],neq,true,vs) ;
      // Backward sweep
      $FSGSblockedMatrix(Y)->matrixHelp->
	sweep(X,B,D,pivot,CLR,F,&matrix.foffsets[0],neq,false,vs) ;
      
      if(printResidual) {
        double residl = 0 ;
        for(int i=0;i<matrix.nmyeqn*vs;++i) {
          double r = realToDouble(X[i]-x2[i]) ;
          x2[i] = X[i] ;
          residl += r*r ;
        }
        double resid = 0 ;
        MPI_Allreduce(&residl,&resid,1,MPI_DOUBLE,MPI_SUM,MPI_COMM_WORLD) ;
        resid = sqrt(resid) ;
        if(0 == iter)
          zero_resid = max(resid,1e-16) ;

        double rel_resid = resid/zero_resid ;
        if(Loci::MPI_rank == 0) {
          cout << "FSGS Matrix " << *$FSGSMatrixName(Y) 
               << ", iter=" << iter+1 
               << ", resid=" << resid << ", rel_resid=" << rel_resid << endl ;
        }
      }
    }

    for(int i=0;i<matrix.nmyeqn;++i)
      for(int j=0;j<vs;++j)
	$FSGSBlockedSSolve(Y)[matrix.eql2g[i]][j] = X[i*vs+j] ;
  } ;

}
